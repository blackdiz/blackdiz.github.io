<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>note on Blackdiz's Garage</title><link>https://blackdiz.github.io/categories/note/</link><description>Recent content in note on Blackdiz's Garage</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Sat, 14 Aug 2021 22:33:38 +0800</lastBuildDate><atom:link href="https://blackdiz.github.io/categories/note/index.xml" rel="self" type="application/rss+xml"/><item><title>Higher Order Function 小記</title><link>https://blackdiz.github.io/blog/higher-order-function/</link><pubDate>Sat, 14 Aug 2021 22:33:38 +0800</pubDate><guid>https://blackdiz.github.io/blog/higher-order-function/</guid><description>在 Functional Programming (函式程式設計) 的世界中，function (函式) 本身可以接受另一個 function 的做為參數，或是返回一個 function 做為回傳值，這就是所謂 Higher Order Function。
以 JavaScript 為例，比方我們想在每次執行 function 時附帶執行 1 個 function，我們可以把要附帶執行的 function 做為參數傳入：
let f = function() { console.log(&amp;#34;I&amp;#39;m callback&amp;#34;); } // 這裡 callback function 做為參數傳入 function add(a, b, callback) { // 所以我們可以在 a + b 之前執行傳入的 function callback(); return a + b } let sum = add(3, 4, f); console.log(sum); 會印出：
I'm callback 7 另一方面我們也可以回傳 function，這裡的 addThree() 回傳一個 function 是接受一個參數 x 回傳 x + 3，所以 sum(4)，會得到 7：</description></item><item><title>Linux 2、1、&amp; 和 ></title><link>https://blackdiz.github.io/blog/linux-redirection-operators/</link><pubDate>Wed, 21 Jul 2021 20:28:15 +0800</pubDate><guid>https://blackdiz.github.io/blog/linux-redirection-operators/</guid><description>小記一下 command 2&amp;gt;&amp;amp;1 &amp;gt; /dev/null 和 command &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 的差別。首先先看 2&amp;gt;&amp;amp;1 的意思。在 Linux 的 file descriptor 中，1 表示 stdout (標準輸出) 表示程式執行中輸出訊息的地方，預設為 terminal。而 2 表示 stderr (標準錯誤輸出) 表示程式執行中發生錯誤時輸出錯誤訊息的地方，預設也是 terminal。
&amp;gt; 表示把 &amp;gt; 前方的輸出都導到 &amp;gt; 後方的目標。
而 &amp;gt;&amp;amp; 表示把 &amp;gt;&amp;amp; 前的 file descriptor 指向 &amp;gt;&amp;amp; 後方的 file descriptor，&amp;amp; 表示目標是 file descriptor 而不是檔案。
/dev/null 是個特殊的目標，任何輸入到它的訊息都會消失不會輸出到任何其他地方。
在了解各部分的作用後，現在把它們組合起來看，command 2&amp;gt;&amp;amp;1 &amp;gt; /dev/null 表示執行 command，把 stderr 輸出的目標指向 stdout 目前輸出的目標，因為 stdout 目前指向的目標是 terminal，所以 stderr 指向的目標就變成 terminal，最後 &amp;gt; /dev/null 表示把 stdout 輸出的目標指向 /dev/null，所以最終執行的結果就是 stderr 會輸出到 terminal 而 stdout 會輸出到 /dev/null。 command &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 則是執行 command，&amp;gt; /dev/null 會把 stdout 輸出目標指向 /dev/null，而最後面的 2&amp;gt;&amp;amp;1 會再把 stderr 輸出的目標指向目前 stdout 的輸出目標，所以也同樣變成 /dev/null，因此最終執行結果會是 stdout 和 stderr 都會輸出到 /dev/null 中。</description></item><item><title>Bitwise Operators</title><link>https://blackdiz.github.io/blog/bitwise-operators/</link><pubDate>Wed, 21 Jul 2021 20:12:53 +0800</pubDate><guid>https://blackdiz.github.io/blog/bitwise-operators/</guid><description>以前覺得位元邏輯操作很難記，但昨天仔細看了一下後突然了解到之前沒有特別去理解 0 和 1 代表的意思而是用死背的方式，所以才容易忘記規則。 其實只要記住 0 == false、1 == true 就會發現規則其實和程式中的 &amp;amp;&amp;amp; 和 || 意思相同。
雖然我想其實應該是反過來，先有 &amp;amp; (AND)、| (OR) 的定義，程式語言才用 &amp;amp;&amp;amp; 和 || 來作出 shortcut logic，但對像我這種半路直接學程式語言的人來說，借用程式語言的語義來記憶比較容易。 所以 &amp;amp; 和 &amp;amp;&amp;amp; 相同，表示要兩邊都為 true 才會輸出 true，否則為 false。而 | 和 || 相同，只要有一邊為 true 就會輸出 true：
&amp;amp; 0 1 0 0 0 1 0 1 | 0 1 0 0 1 1 1 1 而 ^ (XOR) 表示只有完全符合 OR 也就除了要有一邊是 true 以外，另一邊必須是 false 才會輸出 true，而兩邊都是 true 的情況下依然輸出 false：</description></item><item><title>Java: Comparison method violates its general contract!</title><link>https://blackdiz.github.io/blog/comparison-violation/</link><pubDate>Sun, 11 Jul 2021 23:58:09 +0800</pubDate><guid>https://blackdiz.github.io/blog/comparison-violation/</guid><description>前陣子和朋友討論一個奇妙的錯誤訊息，說在執行 Collections.sort(list) 時會出現。第一眼看到這個錯誤訊息 Comparison method violates its general contract!，腦中只冒出無限多個問號，心中只有 OS：「這些工程師什麼時候才能好好說句人話&amp;hellip;」(話說你自己不也是工程師嘛)，沒辦法只好請出 Google 大神，誰叫我們都是 Google 工程師嘛。
原來在 JDK 1.7 後引入了 Tim Sort 這個排序法，Tim Sort 是 Merge Sort 的變型但更有效率，至於 Tim Sort 和 Merge Sort 具體的排序細節為何則不在本文範圍內(其實是我自己也還沒搞清楚 Tim Sort…)。 雖然比較有效率，但對於排序時如何比較被排序元素大小的邏輯正確性就更要求，要能使用 Collections.sort 的元素必須實作 Comparable 的 toCompare method，根據 API 說明，實作 compareTo 時，比較元素大小的邏輯必須符合下列原則：
相反性： A &amp;gt; B 時，必須符合 -A &amp;lt; B 遞延性：A &amp;gt; B 且 B &amp;gt; C 時，必須符合 A &amp;gt; C 必須符合 A == B 時，A == C 且 B == C 如果有違反這 3 個原則的話，有可能會在排序過程中拋出 IllegalArgumentException: Comparison method violates its general contract!</description></item><item><title>Use FreeMarker Template to Output JSON</title><link>https://blackdiz.github.io/blog/freemarker-json/</link><pubDate>Tue, 06 Jul 2021 01:28:39 +0800</pubDate><guid>https://blackdiz.github.io/blog/freemarker-json/</guid><description>首先我們先準備一個 FreeMarker 的 template: test.fltj, fltj 是我們自創給 JSON 格式 tempalte 的副檔名:
{ &amp;quot;name&amp;quot;: &amp;quot;test&amp;quot;, ${content} } ${content} 就是我們等會兒要動態設置的部分。
接著我們需要建立 FreeMarker 的 Configruation，這個 Configuration 理論上只需要建立一個：
Configuration configuration = new Configuration(Configuration.VERSION_2_3_25); // 這裡設定 JSON 範本的路徑 configuration.setClassForTemplateLoading(this.getClass(), &amp;#34;/templates/json-templates&amp;#34;); configuration.setDefaultEncoding(&amp;#34;UTF-8&amp;#34;); configuration.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER); configuration.setLogTemplateExceptions(false); 這裡我們使用 jackson 這個 library 來幫我們把 Java 物件轉成 JSON 格式的字串：
Map&amp;lt;String, Object&amp;gt; data = new HashMap&amp;lt;&amp;gt;(); data.put(&amp;#34;text&amp;#34;, &amp;#34;test message&amp;#34;); data.put(&amp;#34;age&amp;#34;, 23); data.put(&amp;#34;boolean&amp;#34;, true); ObjectMapper mapper = new ObjectMapper(); // writerWithDefaultPrettyPrinter() 會排版輸出的結果 String jsonString = mapper.</description></item><item><title>H2 Database and SQL Alias Column Name</title><link>https://blackdiz.github.io/blog/sql-and-h2-db/</link><pubDate>Tue, 08 Jun 2021 07:59:46 +0800</pubDate><guid>https://blackdiz.github.io/blog/sql-and-h2-db/</guid><description>朋友問了一個奇妙的狀況，下面這個 Spring JPA 的 NativeQuery 回傳的 column name 應該是 as 之後的名稱 (以下為測試的 NativeQuery，非朋友實際執行的 SQL)：
String sql = &amp;#34;select Name as Name, SeqNo as SeqNo from Test where Name = :name&amp;#34;; List&amp;lt;Tuple&amp;gt; result = entityManager.createNativeQuery(sql, Tuple.class).setParameter(&amp;#34;name&amp;#34;, name) .getResultList(); return result; 也就是 Name 和 SeqNo，但跑出來的結果卻是全大寫的 NAME 和 SEQNO：
而且我使用 SQLServer 測試時無法重現這個狀況。一開始以為是不是 Spring JPA 的設定問題，但 Google 大神沒有降什麼神旨，翻了 Spring JPA 的文件也沒看到什麼相關的設定，想說只好用 debug 模式來追蹤一下到底執行過程中是不是有什麼地方會去修改 alias column name。 在追蹤的過程中，突然看到這行：
雖然和執行過程無關 😅，但 factory.getJdbcServices().getDialect() 讓我想到朋友用的是 H2 Database，馬上去官網查了一下發現果然是因為 H2 預設對於沒有使用 &amp;quot;&amp;quot; 括起來的欄位名稱都會依設定轉成全大寫或全小寫：</description></item><item><title>從 Server 端輸出下載的檔名含有中文會變成亂碼問題</title><link>https://blackdiz.github.io/blog/garbled-file-name/</link><pubDate>Mon, 22 Mar 2021 15:15:46 +0800</pubDate><guid>https://blackdiz.github.io/blog/garbled-file-name/</guid><description>朋友遇到一個問題是如果檔名有中文，在瀏覽器下載時檔名會變成亂碼。
首先，瀏覽器是用 header 中的 Content-Disposition=attachment;filename=${檔名} 做為預設的下載檔名，但 header 中並不支援 UTF-8 編碼，所以如果在程式中直接拿中文檔名放在 filename 中就會變成亂碼。
解決方法是先把檔名 encode 成 URL-encoded 編碼，在 Java 中可以用 URLEncoder 處理：
response.setHeader(&amp;#34;Content-Disposition&amp;#34;, &amp;#34;attachment;filename=&amp;#34; + URLEncoder.encode(fileName, &amp;#34;UTF-8&amp;#34;); 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄</description></item></channel></rss>