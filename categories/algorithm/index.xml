<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on Blackdiz's Garage</title><link>https://blackdiz.github.io/categories/algorithm/</link><description>Recent content in algorithm on Blackdiz's Garage</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Sun, 23 Jan 2022 16:40:51 +0800</lastBuildDate><atom:link href="https://blackdiz.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Advent of Code 2021 Day 1</title><link>https://blackdiz.github.io/blog/advent-of-code-2021-day1/</link><pubDate>Sun, 23 Jan 2022 16:40:51 +0800</pubDate><guid>https://blackdiz.github.io/blog/advent-of-code-2021-day1/</guid><description>Advent of Code 是一個很有趣的程式測驗活動，Advent 的意思是「將臨期」指的是為了慶祝耶穌聖誕前的準備期與等待期，所以每年聖誕節前夕，Advent of Code 網站會開始為期 25 天的活動，每天都會有一道題目一直到聖誕節前一天。 Advent of Code 的題目會和聖誕節作連結，而且題目會是一個個相關的情節，玩起來就像在看故事一般，和 LeetCode、Hacker Rank 等知名的刷題網站相比起來比較不會有為了解題而解題的感覺，常常為了看之後的故事而更有動力去解題。 每天的題目會分成兩部分，要先解完 Part 1 才能解 Part 2，通常 Part 1 的難度都滿簡單的有點像是熱身用的題目，而 Part 2 才是重頭戲，另外網站沒有自動檢查輸入測資的機制，所有測資都是純文字必須自己用程式讀取也是和一般像是 LeetCode 等刷題網站相比比較特別的地方。
其實 1、2 年前就知道這個活動，但那個時候對演算法和資料結構不熟覺得解題感覺是一件很可怕的事 😆，2021 年想說有稍微學了一下演算法和資料結構了決定來挑戰一下。一開始想說要符合活動目標拚在聖誕節前夕解完所有題目，但現實果然很殘酷&amp;hellip;，不過既然開始了，而且我也很想看到故事的結局所以決定把它解完，順便記錄一下解法，也算是給自己的一個小挑戰。
在寫下這篇時是解到第 10 天，到第 10 天為止的解法都是我自己想的，所以不一定是最佳解，另外如果真的解不出來去抄襲參考別人的解法會特別註明。而這次解題我想說順便學習一下 Python，所以所有解法都是用 Python 解，同時也有上傳到 Github: Advent of Code 2021，另外這是 Advent of Code 2021 的官網，官網上也有留著歷年的題目可以玩哦。
那麼就讓我們開始冒險的旅程吧~
Day 1: Sonar Sweep Part 1 You&amp;rsquo;re minding your own business on a ship at sea when the overboard alarm goes off!</description></item><item><title>Leetcode 136. Single Number</title><link>https://blackdiz.github.io/blog/leetcode-136/</link><pubDate>Sun, 27 Jun 2021 21:35:21 +0800</pubDate><guid>https://blackdiz.github.io/blog/leetcode-136/</guid><description>LeetCode 136. Single Number Easy
題目 Given a non-empty array of integers, every element appears twice except for one. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,1] Output: 1 Example 2:
Input: [4,1,2,1,2] Output: 4 解決方法 1 (My Own Solution) 用最笨的暴力方式每次取 1 個元素和它以外的元素比對, 比到重複的就跳出該次迴圈直到找到沒重複的。 這題如果只是要求解的話很簡單，除了用巢狀回圈外，還可以遍歷陣列用 Map 記錄元素出現個次數後，再從 Map 中找出只現在一次的元素，但這些簡單的解法都不符合額外的要求，也就是必須在 $O(N)$ 的時間複雜度下不使用額外的空間，所以就不列出其他這類簡單解法了。
Java Code class Solution { public int singleNumber(int[] nums) { int singleNumber = nums[0]; for (int i = 0; i &amp;lt; nums.</description></item><item><title>LeetCode 104. Maximum Depth of Binary Tree</title><link>https://blackdiz.github.io/blog/leetcode-104/</link><pubDate>Wed, 09 Jun 2021 01:14:14 +0800</pubDate><guid>https://blackdiz.github.io/blog/leetcode-104/</guid><description>LeetCode 104. Maximum Depth of Binary Tree Easy
題目 Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Note: A leaf is a node with no children.
Example:
Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 return its depth = 3.
解決方法 1 (My Own Solution) 我們用 2 個變數分別記錄目前所在的層數和目前到過的最大層數，每到一層時如果目前所在的層數大於到過的最大層數就更新最大層數。</description></item><item><title>LeetCode 55. Jump Game</title><link>https://blackdiz.github.io/blog/leetcode-55/</link><pubDate>Fri, 04 Jun 2021 07:23:28 +0800</pubDate><guid>https://blackdiz.github.io/blog/leetcode-55/</guid><description>LeetCode 55. Jump Game Medium
Given an array of non-negative integers nums, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.
Example 1:
Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:</description></item><item><title>LeetCode 344. Reverse String</title><link>https://blackdiz.github.io/blog/leetcode-344/</link><pubDate>Fri, 26 Mar 2021 10:56:51 +0800</pubDate><guid>https://blackdiz.github.io/blog/leetcode-344/</guid><description>LeetCode 344. Reverse String Easy
題目 Write a function that reverses a string. The input string is given as an array of characters char[].
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
You may assume all the characters consist of printable ascii characters.
Example 1:
Input: [&amp;quot;h&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;o&amp;quot;] Output: [&amp;quot;o&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;h&amp;quot;] Example 2:
Input: [&amp;quot;H&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;h&amp;quot;] Output: [&amp;quot;h&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;H&amp;quot;] 解決方法1 (My Own Solution) 用兩個指標 start 和 end 分別由陣列第一個和最後一個元素開始交換位置，並且彼此慢慢靠近，因為字串長度可能為奇數或偶數，所以直到 start &amp;gt;= end 為止 (當為奇數時 start == end，當為偶數時兩者會交錯所以用 start &amp;gt; end 判斷)。</description></item><item><title>LeetCode 1. Two Sum</title><link>https://blackdiz.github.io/blog/leetcode-1/</link><pubDate>Tue, 01 Dec 2020 23:10:57 +0800</pubDate><guid>https://blackdiz.github.io/blog/leetcode-1/</guid><description>LeetCode 1. Two Sum Easy
Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example:
Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解決方法 1 (My Own Solution) 直覺的話就是暴力解法，用所有元素組合兩兩相加直到找出加總等於 target 為止。</description></item></channel></rss>