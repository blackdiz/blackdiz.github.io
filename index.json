[{"title":"Leetcode 136. Single Number","date":"","description":"","body":"LeetCode 136. Single Number Easy\n題目 Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\nExample 1:\nInput: [2,2,1] Output: 1 Example 2:\nInput: [4,1,2,1,2] Output: 4 解決方法 1 (My Own Solution) 用最笨的暴力方式每次取 1 個元素和它以外的元素比對, 比到重複的就跳出該次迴圈直到找到沒重複的。 這題如果只是要求解的話很簡單，除了用巢狀回圈外，還可以遍歷陣列用 Map 記錄元素出現個次數後，再從 Map 中找出只現在一次的元素，但這些簡單的解法都不符合額外的要求，也就是必須在 $O(N)$ 的時間複雜度下不使用額外的空間，所以就不列出其他這類簡單解法了。\nJava Code class Solution { public int singleNumber(int[] nums) { int singleNumber = nums[0]; for (int i = 0; i \u0026lt; nums.length; i++) { boolean duplicated = false; // 標記此次比對是否有重複元素  singleNumber = nums[i]; for (int j = 0; j \u0026lt; nums.length; j++) { if (i == j) { // index 相同表示為同個元素, 不用比對  continue; } else if (nums[i] == nums[j]) { // 比對到重複的就可以跳出減少時間消耗  duplicated = true; break; } } if (duplicated) { continue; } else { break; } } return singleNumber; } } 解決方法2 (LeeCode Solution) 對不熟悉位元運算的我來說，這個解法真的是想破頭也想不到的方法，只能說真的透過這題了解到了位元運算的特殊性質。 此解法使用了 XOR 運算來得到答案，XOR 有下列性質：\n 如果用 0 和其他數字作 XOR 運算則得到原數字： $a ⊕ 0 = a$ 如果用相同數字做 XOR 運算則得到 0： $a ⊕ a = 0$  因為 XOR 運算具有交換律，所以順序可以交換，因此可以把所有數字依序做 XOR 運算，最後留下的即為非重複數字：\n$a ⊕ b ⊕ a = ( a ⊕ a ) ⊕ b = 0 ⊕ b = b$\n以題目 [4,1,2,1,2] 為例：\n\\begin{align} \u0026amp;4 ⊕ 1 ⊕ 2 ⊕ 1 ⊕ 2 ⊕ 1\\newline \u0026amp;= 1 ⊕ 1 ⊕ 2 ⊕ 2 ⊕ 4\\newline \u0026amp;= 0 ⊕ 2 ⊕ 2 ⊕ 4\\newline \u0026amp;= 2 ⊕ 2 ⊕ 4\\newline \u0026amp;= 0 ⊕ 4\\newline \u0026amp;= 4\\newline \\end{align}\nJava Code class Solution { public int singleNumber(int[] nums) { int result = 0; for (int i : nums) { result ^= i; } return result; } } 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-136/"},{"title":"LeetCode 104. Maximum Depth of Binary Tree","date":"","description":"","body":"LeetCode 104. Maximum Depth of Binary Tree Easy\n題目 Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNote: A leaf is a node with no children.\nExample:\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7 return its depth = 3.\n解決方法 1 (My Own Solution) 我們用 2 個變數分別記錄目前所在的層數和目前到過的最大層數，每到一層時如果目前所在的層數大於到過的最大層數就更新最大層數。\nJava Code /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int maxDepth(TreeNode root) { int depth = 0; // 記錄目前所在 node 的深度  int maxDepth = 0; // 記錄目前所到最深的深度  int[] tuple = new int[]{depth, maxDepth}; recTraverse(root, tuple); return tuple[1]; } private void recTraverse(TreeNode root, int[] tuple) { if (root == null) { return; } // recTraverse 每呼叫一次表示到新的一層深度所以 depth + 1  tuple[0]++; // 如果目前到達的 depth \u0026gt; maxDepth, maxDepth 用新的 depth 取代  if (tuple[0] \u0026gt; tuple[1]) { tuple[1] = tuple[0]; } if (root.left == null \u0026amp;\u0026amp; root.right == null) { return; } if (root.left != null) { recTraverse(root.left, tuple); // 因為從下一層回來, 所以 depth - 1  tuple[0]--; } if (root.right != null) { recTraverse(root.right, tuple); // 因為從下一層回來, 所以 depth - 1  tuple[0]--; } } } Go Code /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } maxDepth := recMaxDepth(root, 0, 0) return maxDepth } func recMaxDepth(node *TreeNode, currentDepth int, maxDepth int) int { currentDepth++ if currentDepth \u0026gt; maxDepth { maxDepth = currentDepth } if (node.Left == nil \u0026amp;\u0026amp; node.Right == nil) { return maxDepth } if (node.Left != nil) { maxDepth = recMaxDepth(node.Left, currentDepth, maxDepth) } if (node.Right != nil) { maxDepth = recMaxDepth(node.Right, currentDepth, maxDepth) } return maxDepth } 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-104/"},{"title":"H2 Database and SQL Alias Column Name","date":"","description":"","body":"朋友問了一個奇妙的狀況，下面這個 Spring JPA 的 NativeQuery 回傳的 column name 應該是 as 之後的名稱 (以下為測試的 NativeQuery，非朋友實際執行的 SQL)：\nString sql = \u0026#34;select Name as Name, SeqNo as SeqNo from Test where Name = :name\u0026#34;; List\u0026lt;Tuple\u0026gt; result = entityManager.createNativeQuery(sql, Tuple.class).setParameter(\u0026#34;name\u0026#34;, name) .getResultList(); return result; 也就是 Name 和 SeqNo，但跑出來的結果卻是全大寫的 NAME 和 SEQNO：\n而且我使用 SQLServer 測試時無法重現這個狀況。一開始以為是不是 Spring JPA 的設定問題，但 Google 大神沒有降什麼神旨，翻了 Spring JPA 的文件也沒看到什麼相關的設定，想說只好用 debug 模式來追蹤一下到底執行過程中是不是有什麼地方會去修改 alias column name。 在追蹤的過程中，突然看到這行：\n雖然和執行過程無關 😅，但 factory.getJdbcServices().getDialect() 讓我想到朋友用的是 H2 Database，馬上去官網查了一下發現果然是因為 H2 預設對於沒有使用 \u0026quot;\u0026quot; 括起來的欄位名稱都會依設定轉成全大寫或全小寫：\n Name With default settings unquoted names are converted to upper case. There is no maximum name length.\nIdentifiers in H2 are case sensitive by default. Because unquoted names are converted to upper case, they can be written in any case anyway. When both quoted and unquoted names are used for the same identifier the quoted names must be written in upper case. Identifiers with lowercase characters can be written only as a quoted name, they aren\u0026rsquo;t accessible with unquoted names.\nIf DATABASE_TO_UPPER setting is set to FALSE the unquoted names aren\u0026rsquo;t converted to upper case.\nIf DATABASE_TO_LOWER setting is set to TRUE the unquoted names are converted to lower case instead.\nIf CASE_INSENSITIVE_IDENTIFIERS setting is set to TRUE all identifiers are case insensitive.\n 所以如果要保持 SQL 中的大小寫必須用 \u0026quot;\u0026quot; 括起來：\n Quoted Name | \u0026quot; anything \u0026quot; |\nCase of characters in quoted names is preserved as is. Such names can contain spaces. There is no maximum name length. Two double quotes can be used to create a single double quote inside an identifier. With default settings identifiers in H2 are case sensitive.\nExample:\n\u0026ldquo;FirstName\u0026rdquo;\n 因此如果上面的 NativeQuery 改寫成：\nString sql = \u0026#34;select Name as \\\u0026#34;Name\\\u0026#34;, SeqNo as \\\u0026#34;SeqNo\\\u0026#34; from Test where Name = :name\u0026#34;; List\u0026lt;Tuple\u0026gt; result = entityManager.createNativeQuery(sql, Tuple.class).setParameter(\u0026#34;name\u0026#34;, name) .getResultList(); return result; 就可以正常回傳 Name 和 SeqNo：\n其實這件事也讓我在思考，使用像 H2 這樣的 Memory Database 雖然可以加速測試，但畢竟它和正式線上的資料庫不同，這樣的話這些測試是否能真實反映出實際的狀況呢?或者在 Unit Test 時直接使用如 DBUnit 這類的模擬假資料，反正使用 H2 模擬的也一樣只是假資料，而在 Integration Test 時使用和正式環境相同的資料庫這樣才更有意義也不一定?\n如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/sql-and-h2-db/"},{"title":"LeetCode 55. Jump Game","date":"","description":"","body":"LeetCode 55. Jump Game Medium\nGiven an array of non-negative integers nums, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\nExample 1:\nInput: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:\nInput: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 104 0 \u0026lt;= nums[i] \u0026lt;= 105  解決方法 1 (My Own Solution) 根據題目的說明，我們從第 1 個 index 出發，其數字為可走的步數，所以反過來如果我們從最後一個 index 開始往前，只要前 1 個 index 的元素也就是可走的步數大於或等於兩個 index 間的距離就表示可以有辦法走到下一個 index，我們就可以再往前走。 以 Example 1 為例：\n index 3 的步數為 1，等於 index 3 到 index 4 (同時也是終點)的距離 1 表示有辦法走到終點，所以我們可以再往前一個 index 檢查。 index 2 的步數為 1，等於 index 2 到 index 3 的距離 1，再往前一個 index。 index 1 的步數為 3 大於 index 1 到 index 2 的距離 1，再往前一個 index。 index 0 的步數為 2 大於 index 0 到 index 1 的距離 1，因為已經走到起點了，所以 Example 1 的陣列可以從起點走到終點。  同樣的邏輯套用到 Exmaple 2 上:\n index 3 的步數為 0 小於 index 3 到 index 4 的距離 1，但因為在 index 3 之前還是可能有能走到 index 4 的步數，所以我們繼續往前檢查。 index 2 的步數為 1 小於 index 2 到 index 4 的距離 2 再往前 index 1 的步數為 2 小於 index 1 到index 4 的距離 3 再往 index 0 的步數為 3 小於 index 0 到 index 4 的距離 4，因為已經檢查到起點了，所以 Example 2 的陣列沒辦法從起點走到終點。  Java Code class Solution { public boolean canJump(int[] nums) { // 處理陣列長度為 1 時的特殊情況  if (nums.length == 1) { return true; } int i = nums.length - 2; // 兩個 index 間的距離  int distance = 1; // 從倒數第 2 個 index 開始檢查  for (; i \u0026gt;= 0; i--) { if (nums[i] \u0026gt;= distance) { // 如果走到起點表示此陣列可以從起點走到終點  if (i == 0) { return true; } // 當要檢查下一個 index 時，檢查距離重設為 1  distance = 1; continue; } // 如果此 index 的步數不滿足條件，則檢查下一個 index 時，檢查距離要加 1  distance++; } return i == 0; } }  時間複雜度：因為是遍歷陣列，所以時間複雜度為 $O(N)$  解法 2 (LeetCode Forum Solution) 解法方式和解法 1 相同，但程式碼簡潔更多。基本上是將解法 1 中的 index 的元素是否大於或等於 distance 的計算直接用 index + 該 index 的元素 是否大於或等於後一個 index 取代，同時會用 1 個 pointer last 指向可以成功走到後一個 index 的 index 為何，如果最後 last 指到 index 0 表示可以從起點走到終點。\nJava Code class Solution { public boolean canJump(int[] nums) { int last = nums.length - 1; for (int i = nums.length - 2; i \u0026gt;= 0; i--) { // index + index 的元素如果 \u0026gt;= 後 1 個 index, 表示可以從這邊走到後一個 index 的地方, 所以我們可以繼續往前檢查  if (i + nums[i] \u0026gt;= last) { last = i; } } return last == 0; } }  時間複雜度：因為需要遍歷陣列，所以同樣為 $O(N)$  解法 3 (LeetCode Forum Solution) 這個解法的思考方式是，我們從起點開始記錄該 index 的步數最遠可以到的 index (用變數 max 記錄)，然後開始往後遍歷，如果中間有 index 的步數可以把 max 再往更後面推進就更新 max 的值，但如果我們在遍歷的過程中所檢查的 index 已經超出 max 指向的 index，表示我們最遠只能到 max 所指向的 index 而無法到達終點。如果可以順利遍歷完表示 max 最終的數值一定是等於或大於終點的 index。 以 Example 1 為例的話：\n 開始 max = 0，起點 index 0 為 2 所以 max = 2 表示此時我們最遠可以到 index 2。 index 1 為 3 大於 max 所以更新 max = 3 表示此時我們最遠可以到 index 3。 index 2 為 1 小於 max 所以我們可以不用使用它。 index 3 為 1 小於 max 所以我們可以不用使用它。 index 4 為 4 大於 max，同時我們也遍歷到終點了，所以我們可以成功地從起點走到終點。  以 Example 2 為例的話：\n 開始 max = 0，起點 index 0 為 3 所以 max = 3 表示此時我們最遠可以到 index 3。 index 1 為 2 小於 max 所以我們可以不用使用它。 index 2 為 1 小於 max 所以我們可以不用使用它。 index 3 為 0 小於 max 所以我們可以不用使用它。 index 4 為 4 但因為此時我們遍歷到的 index 已經超過 max 指向的 index 了，表示我們最遠只能走到 max 指向的 index 3，因此不可能從起點走到終點。  Java Code class Solution { public boolean canJump(int[] nums) { int max = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (i \u0026gt; max) { return false; } max = Math.max(i + nums[i], max); } return true; } }  時間複雜度：需要遍歷陣列，所以時間複雜度為 $O(N)$  如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-55/"},{"title":"LeetCode 344. Reverse String","date":"","description":"","body":"LeetCode 344. Reverse String Easy\n題目 Write a function that reverses a string. The input string is given as an array of characters char[].\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nYou may assume all the characters consist of printable ascii characters.\nExample 1:\nInput: [\u0026quot;h\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;o\u0026quot;] Output: [\u0026quot;o\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;h\u0026quot;] Example 2:\nInput: [\u0026quot;H\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;h\u0026quot;] Output: [\u0026quot;h\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;H\u0026quot;] 解決方法1 (My Own Solution) 用兩個指標 start 和 end 分別由陣列第一個和最後一個元素開始交換位置，並且彼此慢慢靠近，因為字串長度可能為奇數或偶數，所以直到 start \u0026gt;= end 為止 (當為奇數時 start == end，當為偶數時兩者會交錯所以用 start \u0026gt; end 判斷)。\nJava Code class Solution { public void reverseString(char[] s) { int end = s.length - 1; for (int start = 0; start \u0026lt; s.length; start++) { if (start \u0026gt;= end) { return; } char temp = s[start]; s[start] = s[end]; s[end] = temp; end--; } } } 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-344/"},{"title":"從 Server 端輸出下載的檔名含有中文會變成亂碼問題","date":"","description":"","body":"從 Server 端輸出下載的檔名含有中文會變成亂碼問題 朋友遇到一個問題是如果檔名有中文，在瀏覽器下載時檔名會變成亂碼。\n首先，瀏覽器是用 header 中的 Content-Disposition=attachment;filename=${檔名} 做為預設的下載檔名，但 header 中並不支援 UTF-8 編碼，所以如果在程式中直接拿中文檔名放在 filename 中就會變成亂碼。\n解決方法是先把檔名 encode 成 URL-encoded 編碼，在 Java 中可以用 URLEncoder 處理：\nresponse.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;filename=\u0026#34; + URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;); 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/garbled-file-name/"},{"title":"About","date":"","description":"","body":"一名充滿好奇心的小小工程師，學習程式喜歡了解探究原理。因為自知美感欠知所以興趣集中在後端系統上，覺得看到大系統中每個組件能完美地契合運作是件非常美妙的事。 這裡記錄著各種學習記錄、工作上遇到的各種問題和解法，如果有錯誤的地方歡迎指教。\nEmail: blackdiz@gmail.com\nGithub: https://github.com/blackdiz\n","ref":"/about/"},{"title":"LeetCode 1. Two Sum","date":"","description":"","body":"LeetCode 1. Two Sum Easy\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\nGiven nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解決方法 1 (My Own Solution) 直覺的話就是暴力解法，用所有元素組合兩兩相加直到找出加總等於 target 為止。\nJava Code class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; for (int j = i + 1; j \u0026lt; nums.length; j++) { if (num1 + nums[j] == target) { return new int[]{i, j}; } } } return new int[0]; } } 時間複雜度：每個元素都要遍歷陣列一次，所以有 $N$ 個元素時為 $O(N^2)$。\n解決方法 2 (My Own Solution) 使用 Map 將 {數字 : index} 儲存起來，在遍歷陣列時直接從 Map 取差值，如果有取到則回傳兩者的 index。\nJava Code class Solution { public int twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; records = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { records.put(nums[i], i); } for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; int num2 = target - num1; // 第 2 個條件避免找到自己，例如 6 - 3 = 3 的情況  if (records.get(num2) != null \u0026amp;\u0026amp; records.get(num2) != i) { return new int[]{i, records.get(num2)}; } } return new int[0]; } } 時間複雜度：遍歷 2 次，所以 $N$ 個元素時為 $O(N)$ 空間複雜度：需要用 Map 記錄陣列中的數字和 index，所以為 $O(N)$\n解決方法 3 (LeetCode Solution) 解決方法 2 可以再進一步優化，因為我們是用差值去 Map 中確認有無和差值相同的元素存在，所以如果 num1 + num2 = target 在遇到 num1 時，我們即使用差值 num2 取不到也將 num1 和它的 index 存入 Map 中，在遇到 num2 時用差值 num1 就可以取到 num1 的 index，所以我們可以不用先將陣列中的元素存入 Map 中，而是一邊遍歷一邊存入 Map。 例如 [2, 7, 3, 4] 而 target = 9，遍歷時先遇到 2，差值為 7，此時 Map 中沒有 7 但我們先把 {2: 0} 存入 Map，而繼續遍歷下去遇到 7，差值為 2，此時我們可以在 Map 取到 {2:0}，所以答案就是 [1, 0]。\nJava Code class Solution { public int twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; records = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; int num2 = target - num1; if (records.get(num2) != null) { return new int[]{i, records.get(num2)}; } records.put(num1, i); } return new int[0]; } } Go Code func twoSum(nums []int, target int) []int { record := make(map[int]int) for i := 0; i \u0026lt; len(nums); i++ { n1, ok := record[target - nums[i]]; if (ok) { return []int{i, n1} } record[nums[i]] = i } return []int{} } 時間複雜度：需要遍歷 $N$ 個元素，所以為 $O(N)$ 空間複雜度：需要建立儲存 $N$ 個元素的 Map，所以為 $O(N)$\n如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-1/"}]