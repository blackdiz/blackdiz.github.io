[{"title":"LeetCode 55 . Jump Game","date":"","description":"","body":"LeetCode 55. Jump Game Medium\nGiven an array of non-negative integers nums, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\nExample 1:\nInput: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:\nInput: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 104 0 \u0026lt;= nums[i] \u0026lt;= 105  解法 1 根據題目的說明，我們從第 1 個 index 出發，其數字為可走的步數，所以以反過來如果我們從最後一個 index 開始往前，只要前 1 個 index 的元素也就是可走的步數大於或等於兩個 index 間的距離就表示可以有辦法走到下一個 index，我們就可以再往前走。 以 Example 1 為例：\n index 3 的步數為 1，等於 index 3 到 index 4 (同時也是終點)的距離 1 表示有辦法走到終點，所以我們可以再往前一個 index 檢查。 index 2 的步數為 1，等於 index 2 到 index 3 的距離 1，再往前一個 index。 index 1 的步數為 3 大於 index 1 到 index 2 的距離 1，再往前一個 index。 index 0 的步數為 2 大於 index 0 到 index 1 的距離 1，因為已經走到起點了，所以 Example 1 的陣列可以從起點走到終點。  同樣的邏輯套用到 Exmaple 2 上:\n index 3 的步數為 0 小於 index 3 到 index 4 的距離 1，但因為在 index 3 之前還是可能有能走到 index 4 的步數，所以我們繼續往前檢查。 index 2 的步數為 1 小於 index 2 到 index 4 的距離 2 再往前 index 1 的步數為 2 小於 index 1 到index 4 的距離 3 再往 index 0 的步數為 3 小於 index 0 到 index 4 的距離 4，因為已經檢查到起點了，所以 Example 2 的陣列沒辦法從起點走到終點。  Java Code class Solution { public boolean canJump(int[] nums) { // 處理陣列長度為 1 時的特殊情況  if (nums.length == 1) { return true; } int i = nums.length - 2; // 兩個 index 間的距離  int distance = 1; // 從倒數第 2 個 index 開始檢查  for (; i \u0026gt;= 0; i--) { if (nums[i] \u0026gt;= distance) { // 如果走到起點表示此陣列可以從起點走到終點  if (i == 0) { return true; } // 當要檢查下一個 index 時，檢查距離重設為 1  distance = 1; continue; } // 如果此 index 的步數不滿足條件，則檢查下一個 index 時，檢查距離要加 1  distance++; } return i == 0; } }  時間複雜度：因為是遍歷陣列，所以時間複雜度為 $O(N)$  解法 2 (LeetCode Forum Solution) 解法方式和解法 1 相同，但程式碼簡潔更多。基本上是將解法 1 中的 index 的元素是否大於或等於 steps 的計算直接用 index + 該 index 的元素 是否大於或等於後一個 index 取代，同時會用 1 個 pointer last 指向可以成功走到後一個 index 的 index 為何，如果最後 last 指到 index 0 表示可以從起點走到終點。\nJava Code class Solution { public boolean canJump(int[] nums) { int last = nums.length - 1; for (int i = nums.length - 2; i \u0026gt;= 0; i--) { // index + index 的元素如果 \u0026gt;= 後 1 個 index, 表示可以從這邊走到後一個 index 的地方, 所以我們可以繼續往前檢查  if (i + nums[i] \u0026gt;= last) { last = i; } } return last == 0; } }  時間複雜度：因為需要遍歷陣列，所以同樣為 $O(N)$  解法 3 (LeetCode Forum Solution) 這個解法的思考方式是，我們從起點開始記錄該 index 的步數最遠可以到的 index (用變數 max 記錄)，然後開始往後遍歷，如果中間有 index 的步數可以把 max 再往更後面推進就更新 max 的值，但如果我們在遍歷的過程中所檢查的 index 已經超出 max 指向的 index，表示我們最遠只能到 max 所指向的 index 而無法到達終點。如果可以順利遍歷完表示 max 最終的數值一定是等於或大於終點的 index。 以 Example 1 為例的話：\n 開始 max = 0，起點 index 0 為 2 所以 max = 2 表示此時我們最遠可以到 index 2。 index 1 為 3 大於 max 所以更新 max = 3 表示此時我們最遠可以到 index 3。 index 2 為 1 小於 max 所以我們可以不用使用它。 index 3 為 1 小於 max 所以我們可以不用使用它。 index 4 為 4 大於 max，同時我們也遍歷到終點了，所以我們可以成功地從起點走到終點。  以 Example 2 為例的話：\n 開始 max = 0，起點 index 0 為 3 所以 max = 3 表示此時我們最遠可以到 index 3。 index 1 為 2 小於 max 所以我們可以不用使用它。 index 2 為 1 小於 max 所以我們可以不用使用它。 index 3 為 0 小於 max 所以我們可以不用使用它。 index 4 為 4 但因為此時我們遍歷到的 index 已經超過 max 指向的 index 了，表示我們最遠只能走到 max 指向的 index 3，因此不可能從起點走到終點。  Java Code class Solution { public boolean canJump(int[] nums) { int max = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (i \u0026gt; max) { return false; } max = Math.max(i + nums[i], max); } return true; } }  時間複雜度：需要遍歷陣列，所以時間複雜度為 $O(N)$  ","ref":"/blog/leetcode-55/"},{"title":"LeetCode 344. Reverse String","date":"","description":"","body":"LeetCode 344. Reverse String Easy\n題目 Write a function that reverses a string. The input string is given as an array of characters char[].\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nYou may assume all the characters consist of printable ascii characters.\nExample 1:\nInput: [\u0026quot;h\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;o\u0026quot;] Output: [\u0026quot;o\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;h\u0026quot;] Example 2:\nInput: [\u0026quot;H\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;h\u0026quot;] Output: [\u0026quot;h\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;H\u0026quot;] 解決方法1 用兩個指標 start 和 end 分別由陣列第一個和最後一個元素開始交換位置，並且彼此慢慢靠近，因為字串長度可能為奇數或偶數，所以直到 start \u0026gt;= end 為止 (當為奇數時 start == end，當為偶數時兩者會交錯所以用 start \u0026gt; end 判斷)。\nJava Code class Solution { public void reverseString(char[] s) { int end = s.length - 1; for (int start = 0; start \u0026lt; s.length; start++) { if (start \u0026gt;= end) { return; } char temp = s[start]; s[start] = s[end]; s[end] = temp; end--; } } } ","ref":"/blog/leetcode-344/"},{"title":"從 Server 端輸出下載的檔名含有中文會變成亂碼問題","date":"","description":"","body":"從 Server 端輸出下載的檔名含有中文會變成亂碼問題 朋友遇到一個問題是如果檔名有中文，在瀏覽器下載時檔名會變成亂碼。\n首先，瀏覽器是用 header 中的 Content-Disposition=attachment;filename=${檔名} 做為預設的下載檔名，但 header 中並不支援 UTF-8 編碼，所以如果在程式中直接拿中文檔名放在 filename 中就會變成亂碼。\n解決方法是先把檔名 encode 成 URL-encoded 編碼，在 Java 中可以用 URLEncoder 處理：\nresponse.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;filename=\u0026#34; + URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;); ","ref":"/blog/garbled-file-name/"},{"title":"About","date":"","description":"","body":"一名充滿好奇心的小小工程師，學習程式喜歡了解探究原理。因為自知美感欠知所以興趣集中在後端系統上，覺得看到大系統中每個組件能完美地契合運作是件非常美妙的事。 這裡記錄著各種學習記錄、工作上遇到的各種問題和解法，如果有錯誤的地方歡迎指教。\nEmail: blackdiz@gmail.com\nGithub: https://github.com/blackdiz\n","ref":"/about/"},{"title":"LeetCode 1. Two Sum","date":"","description":"","body":"LeetCode 1. Two Sum Easy\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\nGiven nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解決方法 1 直覺的話就是暴力解法，用所有元素組合兩兩相加直到找出加總等於 target 為止。\nJava Code class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; for (int j = i + 1; j \u0026lt; nums.length; j++) { if (num1 + nums[j] == target) { return new int[]{i, j}; } } } return new int[0]; } } 時間複雜度：每個元素都要遍歷陣列一次，所以有 $N$ 個元素時為 $O(N^2)$。\n解決方法 2 使用 Map 將 {數字 : index} 儲存起來，在遍歷陣列時直接從 Map 取差值，如果有取到則回傳兩者的 index。\nJava Code class Solution { public int twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; records = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { records.put(nums[i], i); } for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; int num2 = target - num1; // 第 2 個條件避免找到自己，例如 6 - 3 = 3 的情況  if (records.get(num2) != null \u0026amp;\u0026amp; records.get(num2) != i) { return new int[]{i, records.get(num2)}; } } return new int[0]; } } 時間複雜度：遍歷 2 次，所以 $N$ 個元素時為 $O(N)$ 空間複雜度：需要用 Map 記錄陣列中的數字和 index，所以為 $O(N)$\n解決方法 3 (LeetCode Solution) 解決方法 2 可以再進一步優化，因為我們是用差值去 Map 中確認有無和差值相同的元素存在，所以如果 num1 + num2 = target 在遇到 num1 時，我們即使用差值 num2 取不到也將 num1 和它的 index 存入 Map 中，在遇到 num2 時用差值 num1 就可以取到 num1 的 index，所以我們可以不用先將陣列中的元素存入 Map 中，而是一邊遍歷一邊存入 Map。 例如 [2, 7, 3, 4] 而 target = 9，遍歷時先遇到 2，差值為 7，此時 Map 中沒有 7 但我們先把 {2: 0} 存入 Map，而繼續遍歷下去遇到 7，差值為 2，此時我們可以在 Map 取到 {2:0}，所以答案就是 [1, 0]。\nJava Code class Solution { public int twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; records = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; int num2 = target - num1; if (records.get(num2) != null) { return new int[]{i, records.get(num2)}; } records.put(num1, i); } return new int[0]; } } Go Code func twoSum(nums []int, target int) []int { record := make(map[int]int) for i := 0; i \u0026lt; len(nums); i++ { n1, ok := record[target - nums[i]]; if (ok) { return []int{i, n1} } record[nums[i]] = i } return []int{} } 時間複雜度：需要遍歷 $N$ 個元素，所以為 $O(N)$ 空間複雜度：需要建立儲存 $N$ 個元素的 Map，所以為 $O(N)$\n","ref":"/blog/leetcode-1/"}]