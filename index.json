[{"title":"Java: Compartion Violation 問題小記","date":"","description":"","body":"前陣子和朋友討論一個奇妙的錯誤訊息，說在執行 Collections.sort(list) 時會出現。第一眼看到這個錯誤訊息，腦中只冒出無限多個問號，心中只有 OS：「這些工程師什麼時候才能好好說句人話\u0026hellip;」(話說你自己不也是工程師嘛)，沒辦法只好請出 Google 大神，誰叫我們都是 Google 工程師嘛。 原來在 JDK 1.7 後引入了 Tim Sort 這個排序法，Tim Sort 是 Merge Sort 的變型但更有效率，至於 Tim Sort 和 Merge Sort 具體的排序細節為何則不在本文範圍內(其實是我自己也還沒搞清楚 Tim Sort…)。 雖然比較有效率，但對於排序時如何比較被排序元素大小的邏輯正確性就更要求，要能使用 Collections.sort 的元素必須實作 Comparable 的 toCompare method，根據 API 說明，實作 compareTo 時，比較元素大小的邏輯必須符合下列原則：\n 相反性： A \u0026gt; B 時，必須符合 -A \u0026lt; B 遞延性：A \u0026gt; B 且 B \u0026gt; C 時，必須符合 A \u0026gt; C 必須符合 A == B 時，A == C 且 B == C  如果有違反這 3 個原則的話，有可能會在排序過程中拋出 IllegalArgumentException: Comparison method violates its general contract! 的錯誤訊息，但這邊要注意的是也只是有可能，有時候會在毫無錯誤的情況下完成排序，但此時也別高興得太早，古語有云：沉默錯誤最可怕…(我自己說的…)，在違反排序原則的情況排出來的結果，可想而知排序的正確性是有問題，但可怕的是我們這時候反而不知道啊，所以知錯能改善莫大焉，你看說程式還能學到人生道理，多划算 😆。 知道出現錯誤的可能原因後，下一步就是如何找出邏輯的問題，這一點其實滿麻煩的，因為實作的邏輯可能有顯而易見的錯誤，但也可能要看傳入的資料而定，並不是任何資料都有可能讓排序邏輯違反原則，像這次遇到問題的排序邏輯：\n// Element.val 是 String public int compareTo(Elment e) { if (e == null || e.val == null) { return -1; } if (this.val == null) { return 1; } if (this.val.matches(\u0026#34;\\\\\\\\+d\u0026#34;) \u0026amp;\u0026amp; this.val.matches(\u0026#34;\\\\\\\\+d\u0026#34;)) { return Intger.parseInt(this.val) - Integer.parseInt(e.val); } return this.val.compareTo(e.val); } 我們來分析一下，首先\n 如果和此元素比較的元素 e 是 null 或 e 的 val 是 null 就回傳 1 表示 e \u0026gt; 此元素 如果此元素比較的元素 e 和 e.val 非 null，但此元素的 val 為 null 則回傳 1 表示 e \u0026lt; 此元素   上面這兩個邏輯處理了元素的 val 為 null 或者一起比較的元素 e 為 null 或 e.val 為 null 的狀況，從回傳值可以看出這個邏輯是想把 null 值往後排序。\n那如果此元素的 val 和 e.val 都有值呢? 這時候就套用下面的邏輯：\n 當此元素的 val 和 e.val 都是純數字的字串時則以轉換成數字比大小 而如果有一邊的 val 字串不是純數字則進直接呼叫 String.compareTo 以字串的方式比較。  這幾個邏輯各別來看都沒什麼問題，數字就用數字比大小，有牽涉到字串就改用字串方式比較，也有考慮到 null 的情況，但是既然有這篇文章當然就是出事啦。 如果您已經看出問題了，那我真心佩服，在當下想了很久但把除錯的目標集中在錯誤的 null 處理邏輯段落，直到 YouTube 上剛好看到某埸演講主題就是 Java 的排序問題，講者提供了一個方式來 debug，在 compareTo 裡將元素值印出來，直到發生錯誤而停下來的前一刻所印出來的數值有可能就是觸發異常邏輯的資料：\n// Element.val 是 String public int compareTo(Elment e) { System.out.println(\u0026#34;this: \u0026#34; + null + \u0026#34;, e: \u0026#34; + (e == null ? \u0026#34;null\u0026#34; : e)); System.out.println(\u0026#34;this.val: \u0026#34; + this.val + \u0026#34;, e.val: \u0026#34; + e.val); if (e == null || e.val == null) { return -1; } if (this.val == null) { return 1; } if (this.val.matches(\u0026#34;\\\\\\\\+d\u0026#34;) \u0026amp;\u0026amp; this.val.matches(\u0026#34;\\\\\\\\+d\u0026#34;)) { return Intger.parseInt(this.val) - Integer.parseInt(e.val); } return this.val.compareTo(e.val); } 當看到印出來的訊息時，突然間謎題全部都解開了(請下 BGM)\n我就是想用到這張圖 最終抓到的問題資料是 8、19、5Z(為保護機密，此資料非實際當事資料)，這三個值有什麼問題呢? 我們來分別套用到排序邏輯上看看。 首先是 8 和 19，這兩個字串都是純數字，所以我們會轉成 int 後比較大小，得到 8 \u0026lt; 19。 接著是 8 和 5Z，5Z 是字串，因此我們會用 \u0026quot;8\u0026quot;.compareTo(\u0026quot;5Z\u0026quot;) 的方式比大小，在 Java 中字串的排序是從最前面的字元開始比較它轉成 Unicode 後的數值，而 \u0026quot;8\u0026quot; \u0026gt; \u0026quot;5\u0026quot; 所以得到 8 \u0026gt; 5Z。 最後是 5Z 和 19，同樣的這裡用字串的方式排序，因為 \u0026quot;5\u0026quot; \u0026gt; \u0026quot;1\u0026quot; 所以得到 5Z \u0026gt; 19。 我們把三個結果擺一起看看：\n 8 \u0026lt; 19 8 \u0026gt; 5Z 19 \u0026lt; 5Z 結果明顯是矛盾的，如果 8 \u0026lt; 19 且 19 \u0026lt; 5Z 那應該是 8 \u0026lt; 5z 才對，所以這個排序邏輯違反了第一項原則。  經過兩個晚上的奮鬥運氣不錯地找到了實作邏輯上的錯誤，在 debug 的過程中很神奇的是同樣的資料在我這邊的測試程式中不會出現錯誤，但最終的排序結果看起來滿奇怪的，也印證了開頭提到的，如果沒有遇到錯誤不一定是好事，因為排序結果可能不是你想要的樣子。 因為之前很少自己實作排序邏輯，通常直接仰賴原生的排序邏輯或者直接在 SQL 中就先排好，所以也是第一次遇上這個問題，現在比較了解在排序實作上必須注意的點，要考慮好 null 的情況還有三原則的部分，另外非常推薦去看看文中提到的演影片，講者示範了很多排序的方式和可能出現的實作錯誤，連結在下方。\n參考資料：\n Comparison Method Violates Its General Contract! (Part 1) by Stuart Marks Comparison Method Violates Its General Contract! (Part 2) by Stuart Marks  如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/compartion-violation/"},{"title":"Use FreeMarker Template to Output JSON","date":"","description":"","body":"Use FreeMarker Template to Output JSON 首先我們先準備一個 FreeMarker 的 template: test.fltj, fltj 是我們自創給 JSON 格式 tempalte 的副檔名:\n{ \u0026quot;name\u0026quot;: \u0026quot;test\u0026quot;, ${content} } ${content} 就是我們等會兒要動態設置的部分。\n接著我們需要建立 FreeMarker 的 Configruation，這個 Configuration 理論上只需要建立一個：\nConfiguration configuration = new Configuration(Configuration.VERSION_2_3_25); // 這裡設定 JSON 範本的路徑  configuration.setClassForTemplateLoading(this.getClass(), \u0026#34;/templates/json-templates\u0026#34;); configuration.setDefaultEncoding(\u0026#34;UTF-8\u0026#34;); configuration.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER); configuration.setLogTemplateExceptions(false); 這裡我們使用 jackson 這個 library 來幫我們把 Java 物件轉成 JSON 格式的字串：\nMap\u0026lt;String, Object\u0026gt; data = new HashMap\u0026lt;\u0026gt;(); data.put(\u0026#34;text\u0026#34;, \u0026#34;test message\u0026#34;); data.put(\u0026#34;age\u0026#34;, 23); data.put(\u0026#34;boolean\u0026#34;, true); ObjectMapper mapper = new ObjectMapper(); // writerWithDefaultPrettyPrinter() 會排版輸出的結果 String jsonString = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(data); 最後我們把得到的 JSON 字串替換掉 ${content} 的部分：\nMap\u0026lt;String, String\u0026gt; content = new HashMap\u0026lt;\u0026gt;(); content.put(\u0026#34;content\u0026#34;, jsonString); Writer writer = new StringWriter(); Template template = configuration.getTemplate(\u0026#34;test.fltj\u0026#34;); template.process(content, writer); 這樣就會把替換後的 JSON 輸出到 StringWriter 中。\n但因為 FreeMarker 預設會 escape 特殊字元，例如 \u0026amp; 會改成 \u0026amp;amp;，\u0026quot; 會改成 \u0026amp;quot;，所以當我們要用動態產生的 JSON 字串替換掉 ${content} 時，輸出的內容中的 \u0026quot; 都會被改成 \u0026amp;quot;，FreeMarker 其實針對不同類型的輸出有內建的一些格式類別預設是否要 escape 的行為設定，而 JSON 格式的預設格式類別是不會 escape 的，因此我們要做的是告訴 FreeMarker 只要 template 副檔名是 json 就套用 JSON 格式的行為，這裡要用到 TemplateConfiguration：\nTemplateConfiguration jsonConfiguration = new TemplateConfiguration(); // JSONOutputFormat.INSTANCE 即 JSON 格式的處理, 不會去 escape 掉特殊字元 jsonConfiguration.setOutputFormat(JSONOutputFormat.INSTANCE); configuration.setTemplateConfigurations( new FirstMatchTemplateConfigurationFactory( new ConditionalTemplateConfigurationFactory( // 這裡設定副檔名是 fltj 就套用 JSON 格式設定  new FileExtentionMatcher(\u0026#34;fltj\u0026#34;), jsonConfiguration) ) ) ) 這樣輸出的最終結果 JSON 就不會 escape 特殊字元了。\n參考資料：\n Apache FreeMarker document: Output formats Apache FreeMarker document: Associating output formats with templates  如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/freemarker-json/"},{"title":"Leetcode 136. Single Number","date":"","description":"","body":"LeetCode 136. Single Number Easy\n題目 Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\nExample 1:\nInput: [2,2,1] Output: 1 Example 2:\nInput: [4,1,2,1,2] Output: 4 解決方法 1 (My Own Solution) 用最笨的暴力方式每次取 1 個元素和它以外的元素比對, 比到重複的就跳出該次迴圈直到找到沒重複的。 這題如果只是要求解的話很簡單，除了用巢狀回圈外，還可以遍歷陣列用 Map 記錄元素出現個次數後，再從 Map 中找出只現在一次的元素，但這些簡單的解法都不符合額外的要求，也就是必須在 $O(N)$ 的時間複雜度下不使用額外的空間，所以就不列出其他這類簡單解法了。\nJava Code class Solution { public int singleNumber(int[] nums) { int singleNumber = nums[0]; for (int i = 0; i \u0026lt; nums.length; i++) { boolean duplicated = false; // 標記此次比對是否有重複元素  singleNumber = nums[i]; for (int j = 0; j \u0026lt; nums.length; j++) { if (i == j) { // index 相同表示為同個元素, 不用比對  continue; } else if (nums[i] == nums[j]) { // 比對到重複的就可以跳出減少時間消耗  duplicated = true; break; } } if (duplicated) { continue; } else { break; } } return singleNumber; } } 解決方法2 (LeeCode Solution) 對不熟悉位元運算的我來說，這個解法真的是想破頭也想不到的方法，只能說真的透過這題了解到了位元運算的特殊性質。 此解法使用了 XOR 運算來得到答案，XOR 有下列性質：\n 如果用 0 和其他數字作 XOR 運算則得到原數字： $a ⊕ 0 = a$ 如果用相同數字做 XOR 運算則得到 0： $a ⊕ a = 0$  因為 XOR 運算具有交換律，所以順序可以交換，因此可以把所有數字依序做 XOR 運算，最後留下的即為非重複數字：\n$a ⊕ b ⊕ a = ( a ⊕ a ) ⊕ b = 0 ⊕ b = b$\n以題目 [4,1,2,1,2] 為例：\n\\begin{align} \u0026amp;4 ⊕ 1 ⊕ 2 ⊕ 1 ⊕ 2 ⊕ 1\\newline \u0026amp;= 1 ⊕ 1 ⊕ 2 ⊕ 2 ⊕ 4\\newline \u0026amp;= 0 ⊕ 2 ⊕ 2 ⊕ 4\\newline \u0026amp;= 2 ⊕ 2 ⊕ 4\\newline \u0026amp;= 0 ⊕ 4\\newline \u0026amp;= 4\\newline \\end{align}\nJava Code class Solution { public int singleNumber(int[] nums) { int result = 0; for (int i : nums) { result ^= i; } return result; } } 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-136/"},{"title":"LeetCode 104. Maximum Depth of Binary Tree","date":"","description":"","body":"LeetCode 104. Maximum Depth of Binary Tree Easy\n題目 Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNote: A leaf is a node with no children.\nExample:\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7 return its depth = 3.\n解決方法 1 (My Own Solution) 我們用 2 個變數分別記錄目前所在的層數和目前到過的最大層數，每到一層時如果目前所在的層數大於到過的最大層數就更新最大層數。\nJava Code /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int maxDepth(TreeNode root) { int depth = 0; // 記錄目前所在 node 的深度  int maxDepth = 0; // 記錄目前所到最深的深度  int[] tuple = new int[]{depth, maxDepth}; recTraverse(root, tuple); return tuple[1]; } private void recTraverse(TreeNode root, int[] tuple) { if (root == null) { return; } // recTraverse 每呼叫一次表示到新的一層深度所以 depth + 1  tuple[0]++; // 如果目前到達的 depth \u0026gt; maxDepth, maxDepth 用新的 depth 取代  if (tuple[0] \u0026gt; tuple[1]) { tuple[1] = tuple[0]; } if (root.left == null \u0026amp;\u0026amp; root.right == null) { return; } if (root.left != null) { recTraverse(root.left, tuple); // 因為從下一層回來, 所以 depth - 1  tuple[0]--; } if (root.right != null) { recTraverse(root.right, tuple); // 因為從下一層回來, 所以 depth - 1  tuple[0]--; } } } Go Code /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } maxDepth := recMaxDepth(root, 0, 0) return maxDepth } func recMaxDepth(node *TreeNode, currentDepth int, maxDepth int) int { currentDepth++ if currentDepth \u0026gt; maxDepth { maxDepth = currentDepth } if (node.Left == nil \u0026amp;\u0026amp; node.Right == nil) { return maxDepth } if (node.Left != nil) { maxDepth = recMaxDepth(node.Left, currentDepth, maxDepth) } if (node.Right != nil) { maxDepth = recMaxDepth(node.Right, currentDepth, maxDepth) } return maxDepth } 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-104/"},{"title":"H2 Database and SQL Alias Column Name","date":"","description":"","body":"朋友問了一個奇妙的狀況，下面這個 Spring JPA 的 NativeQuery 回傳的 column name 應該是 as 之後的名稱 (以下為測試的 NativeQuery，非朋友實際執行的 SQL)：\nString sql = \u0026#34;select Name as Name, SeqNo as SeqNo from Test where Name = :name\u0026#34;; List\u0026lt;Tuple\u0026gt; result = entityManager.createNativeQuery(sql, Tuple.class).setParameter(\u0026#34;name\u0026#34;, name) .getResultList(); return result; 也就是 Name 和 SeqNo，但跑出來的結果卻是全大寫的 NAME 和 SEQNO：\n而且我使用 SQLServer 測試時無法重現這個狀況。一開始以為是不是 Spring JPA 的設定問題，但 Google 大神沒有降什麼神旨，翻了 Spring JPA 的文件也沒看到什麼相關的設定，想說只好用 debug 模式來追蹤一下到底執行過程中是不是有什麼地方會去修改 alias column name。 在追蹤的過程中，突然看到這行：\n雖然和執行過程無關 😅，但 factory.getJdbcServices().getDialect() 讓我想到朋友用的是 H2 Database，馬上去官網查了一下發現果然是因為 H2 預設對於沒有使用 \u0026quot;\u0026quot; 括起來的欄位名稱都會依設定轉成全大寫或全小寫：\n Name With default settings unquoted names are converted to upper case. There is no maximum name length.\nIdentifiers in H2 are case sensitive by default. Because unquoted names are converted to upper case, they can be written in any case anyway. When both quoted and unquoted names are used for the same identifier the quoted names must be written in upper case. Identifiers with lowercase characters can be written only as a quoted name, they aren\u0026rsquo;t accessible with unquoted names.\nIf DATABASE_TO_UPPER setting is set to FALSE the unquoted names aren\u0026rsquo;t converted to upper case.\nIf DATABASE_TO_LOWER setting is set to TRUE the unquoted names are converted to lower case instead.\nIf CASE_INSENSITIVE_IDENTIFIERS setting is set to TRUE all identifiers are case insensitive.\n 所以如果要保持 SQL 中的大小寫必須用 \u0026quot;\u0026quot; 括起來：\n Quoted Name | \u0026quot; anything \u0026quot; |\nCase of characters in quoted names is preserved as is. Such names can contain spaces. There is no maximum name length. Two double quotes can be used to create a single double quote inside an identifier. With default settings identifiers in H2 are case sensitive.\nExample:\n\u0026ldquo;FirstName\u0026rdquo;\n 因此如果上面的 NativeQuery 改寫成：\nString sql = \u0026#34;select Name as \\\u0026#34;Name\\\u0026#34;, SeqNo as \\\u0026#34;SeqNo\\\u0026#34; from Test where Name = :name\u0026#34;; List\u0026lt;Tuple\u0026gt; result = entityManager.createNativeQuery(sql, Tuple.class).setParameter(\u0026#34;name\u0026#34;, name) .getResultList(); return result; 就可以正常回傳 Name 和 SeqNo：\n其實這件事也讓我在思考，使用像 H2 這樣的 Memory Database 雖然可以加速測試，但畢竟它和正式線上的資料庫不同，這樣的話這些測試是否能真實反映出實際的狀況呢?或者在 Unit Test 時直接使用如 DBUnit 這類的模擬假資料，反正使用 H2 模擬的也一樣只是假資料，而在 Integration Test 時使用和正式環境相同的資料庫這樣才更有意義也不一定?\n如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/sql-and-h2-db/"},{"title":"LeetCode 55. Jump Game","date":"","description":"","body":"LeetCode 55. Jump Game Medium\nGiven an array of non-negative integers nums, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\nExample 1:\nInput: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:\nInput: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 104 0 \u0026lt;= nums[i] \u0026lt;= 105  解決方法 1 (My Own Solution) 根據題目的說明，我們從第 1 個 index 出發，其數字為可走的步數，所以反過來如果我們從最後一個 index 開始往前，只要前 1 個 index 的元素也就是可走的步數大於或等於兩個 index 間的距離就表示可以有辦法走到下一個 index，我們就可以再往前走。 以 Example 1 為例：\n index 3 的步數為 1，等於 index 3 到 index 4 (同時也是終點)的距離 1 表示有辦法走到終點，所以我們可以再往前一個 index 檢查。 index 2 的步數為 1，等於 index 2 到 index 3 的距離 1，再往前一個 index。 index 1 的步數為 3 大於 index 1 到 index 2 的距離 1，再往前一個 index。 index 0 的步數為 2 大於 index 0 到 index 1 的距離 1，因為已經走到起點了，所以 Example 1 的陣列可以從起點走到終點。  同樣的邏輯套用到 Exmaple 2 上:\n index 3 的步數為 0 小於 index 3 到 index 4 的距離 1，但因為在 index 3 之前還是可能有能走到 index 4 的步數，所以我們繼續往前檢查。 index 2 的步數為 1 小於 index 2 到 index 4 的距離 2 再往前 index 1 的步數為 2 小於 index 1 到index 4 的距離 3 再往 index 0 的步數為 3 小於 index 0 到 index 4 的距離 4，因為已經檢查到起點了，所以 Example 2 的陣列沒辦法從起點走到終點。  Java Code class Solution { public boolean canJump(int[] nums) { // 處理陣列長度為 1 時的特殊情況  if (nums.length == 1) { return true; } int i = nums.length - 2; // 兩個 index 間的距離  int distance = 1; // 從倒數第 2 個 index 開始檢查  for (; i \u0026gt;= 0; i--) { if (nums[i] \u0026gt;= distance) { // 如果走到起點表示此陣列可以從起點走到終點  if (i == 0) { return true; } // 當要檢查下一個 index 時，檢查距離重設為 1  distance = 1; continue; } // 如果此 index 的步數不滿足條件，則檢查下一個 index 時，檢查距離要加 1  distance++; } return i == 0; } }  時間複雜度：因為是遍歷陣列，所以時間複雜度為 $O(N)$  解法 2 (LeetCode Forum Solution) 解法方式和解法 1 相同，但程式碼簡潔更多。基本上是將解法 1 中的 index 的元素是否大於或等於 distance 的計算直接用 index + 該 index 的元素 是否大於或等於後一個 index 取代，同時會用 1 個 pointer last 指向可以成功走到後一個 index 的 index 為何，如果最後 last 指到 index 0 表示可以從起點走到終點。\nJava Code class Solution { public boolean canJump(int[] nums) { int last = nums.length - 1; for (int i = nums.length - 2; i \u0026gt;= 0; i--) { // index + index 的元素如果 \u0026gt;= 後 1 個 index, 表示可以從這邊走到後一個 index 的地方, 所以我們可以繼續往前檢查  if (i + nums[i] \u0026gt;= last) { last = i; } } return last == 0; } }  時間複雜度：因為需要遍歷陣列，所以同樣為 $O(N)$  解法 3 (LeetCode Forum Solution) 這個解法的思考方式是，我們從起點開始記錄該 index 的步數最遠可以到的 index (用變數 max 記錄)，然後開始往後遍歷，如果中間有 index 的步數可以把 max 再往更後面推進就更新 max 的值，但如果我們在遍歷的過程中所檢查的 index 已經超出 max 指向的 index，表示我們最遠只能到 max 所指向的 index 而無法到達終點。如果可以順利遍歷完表示 max 最終的數值一定是等於或大於終點的 index。 以 Example 1 為例的話：\n 開始 max = 0，起點 index 0 為 2 所以 max = 2 表示此時我們最遠可以到 index 2。 index 1 為 3 大於 max 所以更新 max = 3 表示此時我們最遠可以到 index 3。 index 2 為 1 小於 max 所以我們可以不用使用它。 index 3 為 1 小於 max 所以我們可以不用使用它。 index 4 為 4 大於 max，同時我們也遍歷到終點了，所以我們可以成功地從起點走到終點。  以 Example 2 為例的話：\n 開始 max = 0，起點 index 0 為 3 所以 max = 3 表示此時我們最遠可以到 index 3。 index 1 為 2 小於 max 所以我們可以不用使用它。 index 2 為 1 小於 max 所以我們可以不用使用它。 index 3 為 0 小於 max 所以我們可以不用使用它。 index 4 為 4 但因為此時我們遍歷到的 index 已經超過 max 指向的 index 了，表示我們最遠只能走到 max 指向的 index 3，因此不可能從起點走到終點。  Java Code class Solution { public boolean canJump(int[] nums) { int max = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (i \u0026gt; max) { return false; } max = Math.max(i + nums[i], max); } return true; } }  時間複雜度：需要遍歷陣列，所以時間複雜度為 $O(N)$  如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-55/"},{"title":"LeetCode 344. Reverse String","date":"","description":"","body":"LeetCode 344. Reverse String Easy\n題目 Write a function that reverses a string. The input string is given as an array of characters char[].\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nYou may assume all the characters consist of printable ascii characters.\nExample 1:\nInput: [\u0026quot;h\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;o\u0026quot;] Output: [\u0026quot;o\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;h\u0026quot;] Example 2:\nInput: [\u0026quot;H\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;h\u0026quot;] Output: [\u0026quot;h\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;H\u0026quot;] 解決方法1 (My Own Solution) 用兩個指標 start 和 end 分別由陣列第一個和最後一個元素開始交換位置，並且彼此慢慢靠近，因為字串長度可能為奇數或偶數，所以直到 start \u0026gt;= end 為止 (當為奇數時 start == end，當為偶數時兩者會交錯所以用 start \u0026gt; end 判斷)。\nJava Code class Solution { public void reverseString(char[] s) { int end = s.length - 1; for (int start = 0; start \u0026lt; s.length; start++) { if (start \u0026gt;= end) { return; } char temp = s[start]; s[start] = s[end]; s[end] = temp; end--; } } } 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-344/"},{"title":"從 Server 端輸出下載的檔名含有中文會變成亂碼問題","date":"","description":"","body":"從 Server 端輸出下載的檔名含有中文會變成亂碼問題 朋友遇到一個問題是如果檔名有中文，在瀏覽器下載時檔名會變成亂碼。\n首先，瀏覽器是用 header 中的 Content-Disposition=attachment;filename=${檔名} 做為預設的下載檔名，但 header 中並不支援 UTF-8 編碼，所以如果在程式中直接拿中文檔名放在 filename 中就會變成亂碼。\n解決方法是先把檔名 encode 成 URL-encoded 編碼，在 Java 中可以用 URLEncoder 處理：\nresponse.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;filename=\u0026#34; + URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;); 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/garbled-file-name/"},{"title":"About","date":"","description":"","body":"一名充滿好奇心的小小工程師，學習程式喜歡了解探究原理。因為自知美感欠知所以興趣集中在後端系統上，覺得看到大系統中每個組件能完美地契合運作是件非常美妙的事。 這裡記錄著各種學習記錄、工作上遇到的各種問題和解法，如果有錯誤的地方歡迎指教。\nEmail: blackdiz@gmail.com\nGithub: https://github.com/blackdiz\n","ref":"/about/"},{"title":"LeetCode 1. Two Sum","date":"","description":"","body":"LeetCode 1. Two Sum Easy\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\nGiven nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解決方法 1 (My Own Solution) 直覺的話就是暴力解法，用所有元素組合兩兩相加直到找出加總等於 target 為止。\nJava Code class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; for (int j = i + 1; j \u0026lt; nums.length; j++) { if (num1 + nums[j] == target) { return new int[]{i, j}; } } } return new int[0]; } } 時間複雜度：每個元素都要遍歷陣列一次，所以有 $N$ 個元素時為 $O(N^2)$。\n解決方法 2 (My Own Solution) 使用 Map 將 {數字 : index} 儲存起來，在遍歷陣列時直接從 Map 取差值，如果有取到則回傳兩者的 index。\nJava Code class Solution { public int twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; records = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { records.put(nums[i], i); } for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; int num2 = target - num1; // 第 2 個條件避免找到自己，例如 6 - 3 = 3 的情況  if (records.get(num2) != null \u0026amp;\u0026amp; records.get(num2) != i) { return new int[]{i, records.get(num2)}; } } return new int[0]; } } 時間複雜度：遍歷 2 次，所以 $N$ 個元素時為 $O(N)$ 空間複雜度：需要用 Map 記錄陣列中的數字和 index，所以為 $O(N)$\n解決方法 3 (LeetCode Solution) 解決方法 2 可以再進一步優化，因為我們是用差值去 Map 中確認有無和差值相同的元素存在，所以如果 num1 + num2 = target 在遇到 num1 時，我們即使用差值 num2 取不到也將 num1 和它的 index 存入 Map 中，在遇到 num2 時用差值 num1 就可以取到 num1 的 index，所以我們可以不用先將陣列中的元素存入 Map 中，而是一邊遍歷一邊存入 Map。 例如 [2, 7, 3, 4] 而 target = 9，遍歷時先遇到 2，差值為 7，此時 Map 中沒有 7 但我們先把 {2: 0} 存入 Map，而繼續遍歷下去遇到 7，差值為 2，此時我們可以在 Map 取到 {2:0}，所以答案就是 [1, 0]。\nJava Code class Solution { public int twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; records = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; int num2 = target - num1; if (records.get(num2) != null) { return new int[]{i, records.get(num2)}; } records.put(num1, i); } return new int[0]; } } Go Code func twoSum(nums []int, target int) []int { record := make(map[int]int) for i := 0; i \u0026lt; len(nums); i++ { n1, ok := record[target - nums[i]]; if (ok) { return []int{i, n1} } record[nums[i]] = i } return []int{} } 時間複雜度：需要遍歷 $N$ 個元素，所以為 $O(N)$ 空間複雜度：需要建立儲存 $N$ 個元素的 Map，所以為 $O(N)$\n如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-1/"}]