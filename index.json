[{"title":"Leetcode 344","date":"","description":"","body":"LeetCode 344. Reverse String Easy\n題目 Write a function that reverses a string. The input string is given as an array of characters char[].\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nYou may assume all the characters consist of printable ascii characters.\nExample 1:\nInput: [\u0026quot;h\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;o\u0026quot;] Output: [\u0026quot;o\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;h\u0026quot;] Example 2:\nInput: [\u0026quot;H\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;h\u0026quot;] Output: [\u0026quot;h\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;H\u0026quot;] 解決方法1 用兩個指標 start 和 end 分別由陣列第一個和最後一個元素開始交換位置，並且彼此慢慢靠近，因為字串長度可能為奇數或偶數，所以直到 start \u0026gt;= end 為止 (當為奇數時 start == end，當為偶數時兩者會交錯所以用 start \u0026gt; end 判斷)。\nJava Code class Solution { public void reverseString(char[] s) { int end = s.length - 1; for (int start = 0; start \u0026lt; s.length; start++) { if (start \u0026gt;= end) { return; } char temp = s[start]; s[start] = s[end]; s[end] = temp; end--; } } } ","ref":"/blog/leetcode-344/"},{"title":"從 Server 端輸出下載的檔名含有中文會變成亂碼問題","date":"","description":"","body":"從 Server 端輸出下載的檔名含有中文會變成亂碼問題 朋友遇到一個問題是如果檔名有中文，在瀏覽器下載時檔名會變成亂碼。\n首先，瀏覽器是用 header 中的 Content-Disposition=attachment;filename=${檔名} 做為預設的下載檔名，但 header 中並不支援 UTF-8 編碼，所以如果在程式中直接拿中文檔名放在 filename 中就會變成亂碼。\n解決方法是先把檔名 encode 成 URL-encoded 編碼，在 Java 中可以用 URLEncoder 處理：\nresponse.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;filename=\u0026#34; + URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;); ","ref":"/blog/garbled-file-name/"},{"title":"About","date":"","description":"","body":"一名充滿好奇心的小小工程師，學習程式喜歡了解探究原理。因為自知美感欠知所以興趣集中在後端系統上，覺得看到大系統中每個組件能完美地契合運作是件非常美妙的事。 這裡記錄著各種學習記錄、工作上遇到的各種問題和解法，如果有錯誤的地方歡迎指教。\nEmail: blackdiz@gmail.com\nGithub: https://github.com/blackdiz\n","ref":"/about/"},{"title":"LeetCode 1. Two Sum","date":"","description":"","body":"LeetCode 1. Two Sum Easy\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\nGiven nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解決方法 1 直覺的話就是暴力解法，用所有元素組合兩兩相加直到找出加總等於 target 為止。\nJava Code class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; for (int j = i + 1; j \u0026lt; nums.length; j++) { if (num1 + nums[j] == target) { return new int[]{i, j}; } } } return new int[0]; } } 時間複雜度：每個元素都要遍歷陣列一次，所以有 $N$ 個元素時為 $O(N^2)$。\n解決方法 2 使用 Map 將 {數字 : index} 儲存起來，在遍歷陣列時直接從 Map 取差值，如果有取到則回傳兩者的 index。\nJava Code class Solution { public int twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; records = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { records.put(nums[i], i); } for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; int num2 = target - num1; // 第 2 個條件避免找到自己，例如 6 - 3 = 3 的情況  if (records.get(num2) != null \u0026amp;\u0026amp; records.get(num2) != i) { return new int[]{i, records.get(num2)}; } } return new int[0]; } } 時間複雜度：遍歷 2 次，所以 $N$ 個元素時為 $O(N)$ 空間複雜度：需要用 Map 記錄陣列中的數字和 index，所以為 $O(N)$\n解決方法 3 (LeetCode Solution) 解決方法 2 可以再進一步優化，因為我們是用差值去 Map 中確認有無和差值相同的元素存在，所以如果 num1 + num2 = target 在遇到 num1 時，我們即使用差值 num2 取不到也將 num1 和它的 index 存入 Map 中，在遇到 num2 時用差值 num1 就可以取到 num1 的 index，所以我們可以不用先將陣列中的元素存入 Map 中，而是一邊遍歷一邊存入 Map。 例如 [2, 7, 3, 4] 而 target = 9，遍歷時先遇到 2，差值為 7，此時 Map 中沒有 7 但我們先把 {2: 0} 存入 Map，而繼續遍歷下去遇到 7，差值為 2，此時我們可以在 Map 取到 {2:0}，所以答案就是 [1, 0]。\nJava Code class Solution { public int twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; records = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; int num2 = target - num1; if (records.get(num2) != null) { return new int[]{i, records.get(num2)}; } records.put(num1, i); } return new int[0]; } } Go Code func twoSum(nums []int, target int) []int { record := make(map[int]int) for i := 0; i \u0026lt; len(nums); i++ { n1, ok := record[target - nums[i]]; if (ok) { return []int{i, n1} } record[nums[i]] = i } return []int{} } 時間複雜度：需要遍歷 $N$ 個元素，所以為 $O(N)$ 空間複雜度：需要建立儲存 $N$ 個元素的 Map，所以為 $O(N)$\n","ref":"/blog/leetcode-1/"}]