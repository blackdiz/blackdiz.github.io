[{"title":"Higher Order Function 小記","date":"","description":"","body":"在 Functional Programming (函式程式設計) 的世界中，function (函式) 本身可以接受另一個 function 的做為參數，或是返回一個 function 做為回傳值，這就是所謂 Higher Order Function。\n以 JavaScript 為例，比方我們想在每次執行 function 時附帶執行 1 個 function，我們可以把要附帶執行的 function 做為參數傳入：\nlet f = function() { console.log(\u0026#34;I\u0026#39;m callback\u0026#34;); } // 這裡 callback function 做為參數傳入 function add(a, b, callback) { // 所以我們可以在 a + b 之前執行傳入的 function  callback(); return a + b } let sum = add(3, 4, f); console.log(sum); 會印出：\nI'm callback 7 另一方面我們也可以回傳 function，這裡的 addThree() 回傳一個 function 是接受一個參數 x 回傳 x + 3，所以 sum(4)，會得到 7：\nfunction addThree() { return function(x) { return x + 3; } } /* * sum = function (x) { * return x + 3; * } */ let sum = addThree(); 因此會印出：\n7 應用 在 FP 的世界中，我們可以把 function 用 Higher Order Function 做組合，所以我們可以把常見的執行流程抽象成 function，把執行邏輯做為 function 傳入。常見的有 forEach、map、filter、reduce 等流程 function。\nforEach 我們很常在程式中做的流程之一就是用迴圈對一連串資料比方 Array 或 List 中的元素一個個進行操作，所以這個迴圈流程就可以抽象成一個 function，而執行的流程很簡單：對傳入的一連串資料中 (比方 Array 或 List) 的一個個元素對其執行傳入的 function：\nfunction print(x) { console.log(x); } [1, 2, 3].forEach((i) =\u0026gt; print(i)); 上面的程式中會分別對 Array 中的 1、2﹑3 分別執行 print function 所以會印出：\n1 2 3 而通常我們可以傳入一個 anonymous function (匿名函式)，也就是不用先宣告好 function 直接傳入 function，所以我們可以把上面的程式改寫成：\n// anonymous function 可以不用宣告名字 [1, 2, 3].forEach(function(i) { console.log(i); }); // 在 JavaScript 中可以用 arrow function (箭頭函式) 讓程式更簡潔 [1, 2, 3].forEach((i) =\u0026gt; console.log(i)); map 如果今天我們傳入的 function 是想要把資料操作後再回傳，比方我們想把 [1, 2, 3] 中的元素每個都乘上 3，我們可以用 forEach 來完成：\n// 用來儲存乘 3 後的結果 let newArray = []; [1, 2, 3].forEach((i) =\u0026gt; { newArray.push(i * 3) }); newArray.forEach((i) =\u0026gt; console.log(i)); 這樣會印出：\n3 6 9 但因為這種操作其實也很常見，所以就有 map 這個 function，其執行流程為：對元素執行傳入的 function 並回傳執行後的新元素的列表 (以 JavaScript 來說是 Array )。\n因此上面 forEach 版本可以改寫成：\n/* 因為 map 回傳的是執行後的新元素的 Array ，所以我們可以不用另外建立新的 Array 來儲存。 * 另外因為在 arrow function 中如果只有一行程式比方下面 i * 3，則可以不用 {} 包住，且預設會回傳執行後的 * 結果，所以下面的程式相同於： * let newArray = [1, 2, 3].map((i) { * return i * 3 * }); */ let newArray = [1, 2, 3].map((i) =\u0026gt; i * 3); newArray.forEach((i) =\u0026gt; console.log(i)); filter 另一個很常見的邏輯是，我們需要過濾元素，比方我們想要過濾掉 [1, 2, 3] 中比 2 小的元素，如果用 forEach 的話可以寫成：\nlet newArray = []; [1, 2, 3].forEach((i) =\u0026gt; { if (i \u0026gt; 1) { newArray.push(i); } }); newArray.forEach((i) =\u0026gt; console.log(i)); 這樣會印出：\n2 3 但我們可以用 filter 改寫，filter 的執行邏輯是：傳入一個 function，該 function 對元素執行後回傳的是 true 或 false，根據回傳的值，如果是 true 就放入回傳的列表中，如果是 false 就略過。 比方上面的程式我們可以改寫成：\nlet newArray = [1, 2, 3].filter((i) =\u0026gt; i \u0026gt; 1); newArray.forEach((i) =\u0026gt; console.log(i)); reduce 有時候我們會想對操作完的元素再做統整的處理，比方我們想對 [1, 2, 3] 的每個數字乘 3 後再全部加總，如果用 forEach 的寫法會是：\nlet sum = 0; [1, 2, 3].forEach((i) =\u0026gt; { i = i * 3; sum = sum + i; }); console.log(sum); 這樣會印出 18。 而這個操作可以用 reduce 取代，reduce 我感覺是比之前的幾個 function 複雜，也比較難用文字描述，MDN 上的 reduce 的說明是：\n reduce() 方法將一個累加器及 Array 中每項元素（由左至右）傳入回呼函式，將 Array 化為單一值。\n 基本上我覺得光看文字應該是看不懂在說什麼，所以我們直接透過 API 說明搭配上面的例子來解釋可能比較清楚。 reduce 的 API 是\n arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)\n 接下來我們個別套到上面的例子中來看，首先 arr 就是目標要操作的 Array ，在這裡是 [1, 2, 3]，這應該沒什麼問題。\n接下來 reduce 的參數就比較複雜，先說 initialValue，initialValue 指的是初始值，也就是當 callback 第一次執行時可以傳入 initialValue 使用。所以如果應用到上面的例子的話，我們的目的是想把每個元素加到 sum，而 sum 一開始是 0，因此我們可以傳入 0 做為 initialValue\n而 callback 是針對元素要執行的 function，所以在這邊我們的 callback 中要對每個元素乘 3 而 callback 本身能接受的參數有：\n accumulator：這是指累加值，每次針對一個元素執行完 callback 後會把回傳值傳入下次執行 callback 時的 accumulator，而在第一次執行時如果有傳入 initialValue 的話就會是 initialValue 的值。在我們的例子中，我們想把每個元素加到 sum 中，所以我們將 0 做為 initialValue 傳入，而在每次加完元素後的總和就會做為 accumulator 傳入下次 callback 的執行 currentValue：這是指執行 callback 當下時的目標元素，在這個例子中第一次執行為就會是 1，第二次會是 2 currentIndex：執行 callback 當下時目標元素的 index，在這個例子中第一次執行為就會是 0，第二次會是 1，可以不傳入，在我們的例子不需要使用 array：呼叫 reduce 的 Array ，在這個例子中為 [1, 2, 3]，可以不傳入，在我們的例子用不到  所以這樣套完後，我們可以用 reduce 改寫成：\nlet total = [1, 2, 3].reduce((sum, i) =\u0026gt; { return sum * 3 + i; }, 0); console.log(total); 我們可以把 callback 執行過程拆開來看會更清楚，第一次執行 callback 時會執行像是這樣的 function：\nfunction(0, 1) { return 0 * 3 + 1; } 0 是我們傳入的 initialValue 因為是第一次執行所以會變成 callback 的第一個參數 accumulator，而 1 就是當下處理的元素。\n第二次執行時會把第一次執行的回傳值 1 做為 accumulator 傳入 callback，所以第二次的 function 會是：\nfunction(1, 2) { return 1 * 3 + 2; } 第三次執行則把第二次執行的回傳值 5 傳入，因此第三次的 function 會是：\nfunction(5, 3) { return 5 * 3 + 3; } 在執行完第三次後因為沒有元素了，所以回傳最終結果 18。\n除了這些以外還有很多其他的流程型 function，比方在 JavaScript 中有 find 傳入一個回傳值為 boolean 的 function 並回傳第一個符合 true 的元素，some 傳入回傳值為 boolean 的 function 並回傳 boolean 如果為 true 表示至少有一個元素會讓傳入 function 回傳 true。\n回傳 function 上面提到的都是將 function 做為參數傳入另一個 function 中可做的應用，而應用可回傳 function 的特性我們就可以依據不同參數產生新的 function。\n比方我們今天想要建立一個傳入數字 a 後回傳 a + 3 的 function，這很簡單：\nfunction addThree(a) { return a + 3; } 然後我們想要新的加 4 的 function，這也很簡單：\nfunction addFour(a) { return a + 4; } 但如果我們想要能產生 a 加上任意數字的 function，總不能一一去宣告，這時就可以用上這個特性：\nfunction addNumber(b) { return function(a) { return a + b; }; } let addThree = addNumber(3); console.log(addThree(4)); // 此行印出 7  let addFive = addNumber(5); console.log(addFive(5)); // 此行印出 10 addNumber(b) 這個 function 所做的是將傳入的 b 的值綁定到要回傳的 function 內部的 b 中再回傳，所以 addNumber(3) 會得到：\nfunction(a) { return a + 3; } 而 addNubmer(5) 則會得到：\nfunction(a) { return a + 5; } 上述的應用稱為 Partial Application 也就是我們可以將 function 中的某些參數給予固定值來得到新的 function，新的 function 只需給予剩下的尚未給值的參數，如此我們就可以做更多抽象化來減少程式碼的重複。另一個例子，比方我們可以寫一個 function：\nfunction url(scheme, host, path) { return function(path) { return scheme + \u0026#34;://\u0026#34; + host + \u0026#34;/\u0026#34; + path; }; } 我們可以使用這個 function 產生 function twitter(path) 和 function facebook(path)，只要傳入 path 就可以得到 https://www.twitter.com/{path} 或 https://www.facebook.com/{path}：\nlet twitter = url(\u0026#34;https\u0026#34;, \u0026#34;www.twitter.com\u0026#34;); console.log(twitter(\u0026#34;user\u0026#34;)); // 印出 https://www.twitter.com/user  let facebook = url(\u0026#34;https\u0026#34;, \u0026#34;www.facebook.com\u0026#34;) console.log(facebook(\u0026#34;posts\u0026#34;)); // 印出 https://www.facebook.com/posts 另一個可能的簡單應用是我們可以把讀取檔案的程式和處理檔案的程式分開：\nfunction readFile(callback) { let data = read(\u0026#34;{path}\u0026#34;) // 假使 read 是讀取 path 路徑的檔案  return function(data) { callback(data); }; } // 如此 printFile 會在讀取檔案後印出它的內容 let printFile = readFile((data) =\u0026gt; { console.log(data); }) 如此一來，我們就可以重復使用讀取檔案的程式，只需要傳入不同的處理邏輯就可以得到不同的處理檔案方式。\n結語 上述雖然是以 JavaScript 做為例子，但主要是描述 Higer Order Function 的概念，其他語言可能語法不同，但基本概念相同，在現在大多數語言都支援多範式下，通常也支援程度不一的 Functional Programming，比方 Java 雖然是 Object Oriented Programming (物件導向語言 OOP) 但在 Java 8 後也加入了 Functional Programming 的概念讓我們不必像從前一樣任何實作邏輯都必須先宣告成 class 而讓我們可以寫出更簡潔同時易讀性更高更專注在實作邏輯上的程式。此篇主要是記錄我自己對 Higher Order Function 的了解和比較常運作的部分，除了此篇提到的以外還有很多 Higher Order Function 的應用，比方可以拿來做 Dependency Injection (依賴注入)，或者是實現如 Aspect Oriented Programming (剖面導向 AOP) 的設計，有機會的話再來另外記錄。\n 參考資料\n Wiki - 高階函式 MDN forEach MDN map MDN filter MDN reduce Curry and Function Composition  如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/higher-order-function/"},{"title":"Linux 2、1、& 和 ","date":"","description":"","body":"小記一下 command 2\u0026gt;\u0026amp;1 \u0026gt; /dev/null 和 command \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 的差別。首先先看 2\u0026gt;\u0026amp;1 的意思。在 Linux 的 file descriptor 中，1 表示 stdout (標準輸出) 表示程式執行中輸出訊息的地方，預設為 terminal。而 2 表示 stderr (標準錯誤輸出) 表示程式執行中發生錯誤時輸出錯誤訊息的地方，預設也是 terminal。\n\u0026gt; 表示把 \u0026gt; 前方的輸出都導到 \u0026gt; 後方的目標。\n而 \u0026gt;\u0026amp; 表示把 \u0026gt;\u0026amp; 前的 file descriptor 指向 \u0026gt;\u0026amp; 後方的 file descriptor，\u0026amp; 表示目標是 file descriptor 而不是檔案。\n/dev/null 是個特殊的目標，任何輸入到它的訊息都會消失不會輸出到任何其他地方。\n在了解各部分的作用後，現在把它們組合起來看，command 2\u0026gt;\u0026amp;1 \u0026gt; /dev/null 表示執行 command，把 stderr 輸出的目標指向 stdout 目前輸出的目標，因為 stdout 目前指向的目標是 terminal，所以 stderr 指向的目標就變成 terminal，最後 \u0026gt; /dev/null 表示把 stdout 輸出的目標指向 /dev/null，所以最終執行的結果就是 stderr 會輸出到 terminal 而 stdout 會輸出到 /dev/null。 command \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 則是執行 command，\u0026gt; /dev/null 會把 stdout 輸出目標指向 /dev/null，而最後面的 2\u0026gt;\u0026amp;1 會再把 stderr 輸出的目標指向目前 stdout 的輸出目標，所以也同樣變成 /dev/null，因此最終執行結果會是 stdout 和 stderr 都會輸出到 /dev/null 中。\n所以結論是 command 2\u0026gt;\u0026amp;1 \u0026gt; /dev/null 依然會輸出錯誤訊息到 terminal 上，而 command \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 則不會輸出任何訊息。\n 參考資料：\n Bash One-Liners Explained, Part III: All about redirections  如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/linux-redirection-operators/"},{"title":"Bitwise Operators","date":"","description":"","body":"以前覺得位元邏輯操作很難記，但昨天仔細看了一下後突然了解到之前沒有特別去理解 0 和 1 代表的意思而是用死背的方式，所以才容易忘記規則。 其實只要記住 0 == false、1 == true 就會發現規則其實和程式中的 \u0026amp;\u0026amp; 和 || 意思相同。\n雖然我想其實應該是反過來，先有 \u0026amp; (AND)、| (OR) 的定義，程式語言才用 \u0026amp;\u0026amp; 和 || 來作出 shortcut logic，但對像我這種半路直接學程式語言的人來說，借用程式語言的語義來記憶比較容易。 所以 \u0026amp; 和 \u0026amp;\u0026amp; 相同，表示要兩邊都為 true 才會輸出 true，否則為 false。而 | 和 || 相同，只要有一邊為 true 就會輸出 true：\n   \u0026amp; 0 1     0 0 0   1 0 1       | 0 1     0 0 1   1 1 1    而 ^ (XOR) 表示只有完全符合 OR 也就除了要有一邊是 true 以外，另一邊必須是 false 才會輸出 true，而兩邊都是 true 的情況下依然輸出 false：\n   ^ 0 1     0 0 1   1 1 0    如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/bitwise-operators/"},{"title":"Java: Comparison method violates its general contract!","date":"","description":"","body":"前陣子和朋友討論一個奇妙的錯誤訊息，說在執行 Collections.sort(list) 時會出現。第一眼看到這個錯誤訊息 Comparison method violates its general contract!，腦中只冒出無限多個問號，心中只有 OS：「這些工程師什麼時候才能好好說句人話\u0026hellip;」(話說你自己不也是工程師嘛)，沒辦法只好請出 Google 大神，誰叫我們都是 Google 工程師嘛。\n原來在 JDK 1.7 後引入了 Tim Sort 這個排序法，Tim Sort 是 Merge Sort 的變型但更有效率，至於 Tim Sort 和 Merge Sort 具體的排序細節為何則不在本文範圍內(其實是我自己也還沒搞清楚 Tim Sort…)。 雖然比較有效率，但對於排序時如何比較被排序元素大小的邏輯正確性就更要求，要能使用 Collections.sort 的元素必須實作 Comparable 的 toCompare method，根據 API 說明，實作 compareTo 時，比較元素大小的邏輯必須符合下列原則：\n 相反性： A \u0026gt; B 時，必須符合 -A \u0026lt; B 遞延性：A \u0026gt; B 且 B \u0026gt; C 時，必須符合 A \u0026gt; C 必須符合 A == B 時，A == C 且 B == C  如果有違反這 3 個原則的話，有可能會在排序過程中拋出 IllegalArgumentException: Comparison method violates its general contract! 的錯誤訊息，但這邊要注意的是也只是有可能，有時候會在毫無錯誤的情況下完成排序，但此時也別高興得太早，古語有云：沉默錯誤最可怕…(我自己說的…)，在違反排序原則的情況排出來的結果，可想而知排序的正確性是有問題，但可怕的是我們這時候反而不知道啊，所以知錯能改善莫大焉，你看學程式還能學到人生道理，多划算 😆。\n知道出現錯誤的可能原因後，下一步就是如何找出邏輯的問題，這一點其實滿麻煩的，因為實作的邏輯可能有顯而易見的錯誤，但也可能要看傳入的資料而定，並不是任何資料都有可能讓排序邏輯違反原則，像這次遇到問題的排序邏輯：\n// Element.val 是 String public int compareTo(Elment e) { if (e == null || e.val == null) { return -1; } if (this.val == null) { return 1; } if (this.val.matches(\u0026#34;\\\\\\\\+d\u0026#34;) \u0026amp;\u0026amp; this.val.matches(\u0026#34;\\\\\\\\+d\u0026#34;)) { return Intger.parseInt(this.val) - Integer.parseInt(e.val); } return this.val.compareTo(e.val); } 我們來分析一下，首先\n 如果和此元素比較的元素 e 是 null 或 e 的 val 是 null 就回傳 1 表示 e \u0026gt; 此元素 如果此元素比較的元素 e 和 e.val 非 null，但此元素的 val 為 null 則回傳 1 表示 e \u0026lt; 此元素  上面這兩個邏輯處理了元素的 val 為 null 或者一起比較的元素 e 為 null 或 e.val 為 null 的狀況，從回傳值可以看出這個邏輯是想把 null 值往後排序。\n那如果此元素的 val 和 e.val 都有值呢? 這時候就套用下面的邏輯：\n 當此元素的 val 和 e.val 都是純數字的字串時則以轉換成數字比大小 而如果有一邊的 val 字串不是純數字則進直接呼叫 String.compareTo 以字串的方式比較。  這幾個邏輯各別來看都沒什麼問題，數字就用數字比大小，有牽涉到字串就改用字串方式比較，也有考慮到 null 的情況，但是既然有這篇文章當然就是出事啦。\n如果您已經看出問題了，那我真心佩服，在當下想了很久但把除錯的目標集中在錯誤的 null 處理邏輯段落，直到 YouTube 上剛好看到某埸演講主題就是 Java 的排序問題，講者提供了一個方式來 debug，在 compareTo 裡將元素值印出來，直到發生錯誤而停下來的前一刻所印出來的數值有可能就是觸發異常邏輯的資料：\n// Element.val 是 String public int compareTo(Elment e) { System.out.println(\u0026#34;this: \u0026#34; + null + \u0026#34;, e: \u0026#34; + (e == null ? \u0026#34;null\u0026#34; : e)); System.out.println(\u0026#34;this.val: \u0026#34; + this.val + \u0026#34;, e.val: \u0026#34; + e.val); if (e == null || e.val == null) { return -1; } if (this.val == null) { return 1; } if (this.val.matches(\u0026#34;\\\\\\\\+d\u0026#34;) \u0026amp;\u0026amp; this.val.matches(\u0026#34;\\\\\\\\+d\u0026#34;)) { return Intger.parseInt(this.val) - Integer.parseInt(e.val); } return this.val.compareTo(e.val); } 當看到印出來的訊息時，突然間謎題全部都解開了(請下 BGM)\n我就是想用到這張圖   最終抓到的問題資料是 8、19、5Z(為保護機密，此資料非實際當事資料)，這三個值有什麼問題呢? 我們來分別套用到排序邏輯上看看。 首先是 8 和 19，這兩個字串都是純數字，所以我們會轉成 int 後比較大小，得到 8 \u0026lt; 19。 接著是 8 和 5Z，5Z 是字串，因此我們會用 \u0026quot;8\u0026quot;.compareTo(\u0026quot;5Z\u0026quot;) 的方式比大小，在 Java 中字串的排序是從最前面的字元開始比較它轉成 Unicode 後的數值，而 \u0026quot;8\u0026quot; \u0026gt; \u0026quot;5\u0026quot; 所以得到 8 \u0026gt; 5Z。 最後是 5Z 和 19，同樣的這裡用字串的方式排序，因為 \u0026quot;5\u0026quot; \u0026gt; \u0026quot;1\u0026quot; 所以得到 5Z \u0026gt; 19。 我們把三個結果擺一起看看：\n 8 \u0026lt; 19 8 \u0026gt; 5Z 19 \u0026lt; 5Z 結果明顯是矛盾的，如果 8 \u0026lt; 19 且 19 \u0026lt; 5Z 那應該是 8 \u0026lt; 5z 才對，所以這個排序邏輯違反了第一項原則。  經過兩個晚上的奮鬥運氣不錯地找到了實作邏輯上的錯誤，在 debug 的過程中很神奇的是同樣的資料在我這邊的測試程式中不會出現錯誤，但最終的排序結果看起來滿奇怪的，也印證了開頭提到的，如果沒有遇到錯誤不一定是好事，因為排序結果可能不是你想要的樣子。\n因為之前很少自己實作排序邏輯，通常直接仰賴原生的排序邏輯或者直接在 SQL 中就先排好，所以也是第一次遇上這個問題，現在比較了解在排序實作上必須注意的點，要考慮好 null 的情況還有三原則的部分，另外非常推薦去看看文中提到的演影片，講者示範了很多排序的方式和可能出現的實作錯誤，連結在下方。\n參考資料：\n Comparison Method Violates Its General Contract! (Part 1) by Stuart Marks Comparison Method Violates Its General Contract! (Part 2) by Stuart Marks  如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/comparison-violation/"},{"title":"Use FreeMarker Template to Output JSON","date":"","description":"","body":"首先我們先準備一個 FreeMarker 的 template: test.fltj, fltj 是我們自創給 JSON 格式 tempalte 的副檔名:\n{ \u0026quot;name\u0026quot;: \u0026quot;test\u0026quot;, ${content} } ${content} 就是我們等會兒要動態設置的部分。\n接著我們需要建立 FreeMarker 的 Configruation，這個 Configuration 理論上只需要建立一個：\nConfiguration configuration = new Configuration(Configuration.VERSION_2_3_25); // 這裡設定 JSON 範本的路徑  configuration.setClassForTemplateLoading(this.getClass(), \u0026#34;/templates/json-templates\u0026#34;); configuration.setDefaultEncoding(\u0026#34;UTF-8\u0026#34;); configuration.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER); configuration.setLogTemplateExceptions(false); 這裡我們使用 jackson 這個 library 來幫我們把 Java 物件轉成 JSON 格式的字串：\nMap\u0026lt;String, Object\u0026gt; data = new HashMap\u0026lt;\u0026gt;(); data.put(\u0026#34;text\u0026#34;, \u0026#34;test message\u0026#34;); data.put(\u0026#34;age\u0026#34;, 23); data.put(\u0026#34;boolean\u0026#34;, true); ObjectMapper mapper = new ObjectMapper(); // writerWithDefaultPrettyPrinter() 會排版輸出的結果 String jsonString = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(data); 最後我們把得到的 JSON 字串替換掉 ${content} 的部分：\nMap\u0026lt;String, String\u0026gt; content = new HashMap\u0026lt;\u0026gt;(); content.put(\u0026#34;content\u0026#34;, jsonString); Writer writer = new StringWriter(); Template template = configuration.getTemplate(\u0026#34;test.fltj\u0026#34;); template.process(content, writer); 這樣就會把替換後的 JSON 輸出到 StringWriter 中。\n但因為 FreeMarker 預設會 escape 特殊字元，例如 \u0026amp; 會改成 \u0026amp;amp;，\u0026quot; 會改成 \u0026amp;quot;，所以當我們要用動態產生的 JSON 字串替換掉 ${content} 時，輸出的內容中的 \u0026quot; 都會被改成 \u0026amp;quot;，FreeMarker 其實針對不同類型的輸出有內建的一些格式類別預設是否要 escape 的行為設定，而 JSON 格式的預設格式類別是不會 escape 的，因此我們要做的是告訴 FreeMarker 只要 template 副檔名是 json 就套用 JSON 格式的行為，這裡要用到 TemplateConfiguration：\nTemplateConfiguration jsonConfiguration = new TemplateConfiguration(); // JSONOutputFormat.INSTANCE 即 JSON 格式的處理, 不會去 escape 掉特殊字元 jsonConfiguration.setOutputFormat(JSONOutputFormat.INSTANCE); configuration.setTemplateConfigurations( new FirstMatchTemplateConfigurationFactory( new ConditionalTemplateConfigurationFactory( // 這裡設定副檔名是 fltj 就套用 JSON 格式設定  new FileExtentionMatcher(\u0026#34;fltj\u0026#34;), jsonConfiguration) ) ) ) 這樣輸出的最終結果 JSON 就不會 escape 特殊字元了。\n 參考資料：\n Apache FreeMarker document: Output formats Apache FreeMarker document: Associating output formats with templates  如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/freemarker-json/"},{"title":"Leetcode 136. Single Number","date":"","description":"","body":"LeetCode 136. Single Number Easy\n題目 Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\nExample 1:\nInput: [2,2,1] Output: 1 Example 2:\nInput: [4,1,2,1,2] Output: 4 解決方法 1 (My Own Solution) 用最笨的暴力方式每次取 1 個元素和它以外的元素比對, 比到重複的就跳出該次迴圈直到找到沒重複的。 這題如果只是要求解的話很簡單，除了用巢狀回圈外，還可以遍歷陣列用 Map 記錄元素出現個次數後，再從 Map 中找出只現在一次的元素，但這些簡單的解法都不符合額外的要求，也就是必須在 $O(N)$ 的時間複雜度下不使用額外的空間，所以就不列出其他這類簡單解法了。\nJava Code class Solution { public int singleNumber(int[] nums) { int singleNumber = nums[0]; for (int i = 0; i \u0026lt; nums.length; i++) { boolean duplicated = false; // 標記此次比對是否有重複元素  singleNumber = nums[i]; for (int j = 0; j \u0026lt; nums.length; j++) { if (i == j) { // index 相同表示為同個元素, 不用比對  continue; } else if (nums[i] == nums[j]) { // 比對到重複的就可以跳出減少時間消耗  duplicated = true; break; } } if (duplicated) { continue; } else { break; } } return singleNumber; } } 解決方法2 (LeeCode Solution) 對不熟悉位元運算的我來說，這個解法真的是想破頭也想不到的方法，只能說真的透過這題了解到了位元運算的特殊性質。 此解法使用了 XOR 運算來得到答案，XOR 有下列性質：\n 如果用 0 和其他數字作 XOR 運算則得到原數字： $a ⊕ 0 = a$ 如果用相同數字做 XOR 運算則得到 0： $a ⊕ a = 0$  因為 XOR 運算具有交換律，所以順序可以交換，因此可以把所有數字依序做 XOR 運算，最後留下的即為非重複數字：\n$a ⊕ b ⊕ a = ( a ⊕ a ) ⊕ b = 0 ⊕ b = b$\n以題目 [4,1,2,1,2] 為例：\n\\begin{align} \u0026amp;4 ⊕ 1 ⊕ 2 ⊕ 1 ⊕ 2 ⊕ 1\\newline \u0026amp;= 1 ⊕ 1 ⊕ 2 ⊕ 2 ⊕ 4\\newline \u0026amp;= 0 ⊕ 2 ⊕ 2 ⊕ 4\\newline \u0026amp;= 2 ⊕ 2 ⊕ 4\\newline \u0026amp;= 0 ⊕ 4\\newline \u0026amp;= 4\\newline \\end{align}\nJava Code class Solution { public int singleNumber(int[] nums) { int result = 0; for (int i : nums) { result ^= i; } return result; } } 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-136/"},{"title":"LeetCode 104. Maximum Depth of Binary Tree","date":"","description":"","body":"LeetCode 104. Maximum Depth of Binary Tree Easy\n題目 Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNote: A leaf is a node with no children.\nExample:\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7 return its depth = 3.\n解決方法 1 (My Own Solution) 我們用 2 個變數分別記錄目前所在的層數和目前到過的最大層數，每到一層時如果目前所在的層數大於到過的最大層數就更新最大層數。\nJava Code /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int maxDepth(TreeNode root) { int depth = 0; // 記錄目前所在 node 的深度  int maxDepth = 0; // 記錄目前所到最深的深度  int[] tuple = new int[]{depth, maxDepth}; recTraverse(root, tuple); return tuple[1]; } private void recTraverse(TreeNode root, int[] tuple) { if (root == null) { return; } // recTraverse 每呼叫一次表示到新的一層深度所以 depth + 1  tuple[0]++; // 如果目前到達的 depth \u0026gt; maxDepth, maxDepth 用新的 depth 取代  if (tuple[0] \u0026gt; tuple[1]) { tuple[1] = tuple[0]; } if (root.left == null \u0026amp;\u0026amp; root.right == null) { return; } if (root.left != null) { recTraverse(root.left, tuple); // 因為從下一層回來, 所以 depth - 1  tuple[0]--; } if (root.right != null) { recTraverse(root.right, tuple); // 因為從下一層回來, 所以 depth - 1  tuple[0]--; } } } Go Code /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } maxDepth := recMaxDepth(root, 0, 0) return maxDepth } func recMaxDepth(node *TreeNode, currentDepth int, maxDepth int) int { currentDepth++ if currentDepth \u0026gt; maxDepth { maxDepth = currentDepth } if (node.Left == nil \u0026amp;\u0026amp; node.Right == nil) { return maxDepth } if (node.Left != nil) { maxDepth = recMaxDepth(node.Left, currentDepth, maxDepth) } if (node.Right != nil) { maxDepth = recMaxDepth(node.Right, currentDepth, maxDepth) } return maxDepth } 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-104/"},{"title":"H2 Database and SQL Alias Column Name","date":"","description":"","body":"朋友問了一個奇妙的狀況，下面這個 Spring JPA 的 NativeQuery 回傳的 column name 應該是 as 之後的名稱 (以下為測試的 NativeQuery，非朋友實際執行的 SQL)：\nString sql = \u0026#34;select Name as Name, SeqNo as SeqNo from Test where Name = :name\u0026#34;; List\u0026lt;Tuple\u0026gt; result = entityManager.createNativeQuery(sql, Tuple.class).setParameter(\u0026#34;name\u0026#34;, name) .getResultList(); return result; 也就是 Name 和 SeqNo，但跑出來的結果卻是全大寫的 NAME 和 SEQNO：\n而且我使用 SQLServer 測試時無法重現這個狀況。一開始以為是不是 Spring JPA 的設定問題，但 Google 大神沒有降什麼神旨，翻了 Spring JPA 的文件也沒看到什麼相關的設定，想說只好用 debug 模式來追蹤一下到底執行過程中是不是有什麼地方會去修改 alias column name。 在追蹤的過程中，突然看到這行：\n雖然和執行過程無關 😅，但 factory.getJdbcServices().getDialect() 讓我想到朋友用的是 H2 Database，馬上去官網查了一下發現果然是因為 H2 預設對於沒有使用 \u0026quot;\u0026quot; 括起來的欄位名稱都會依設定轉成全大寫或全小寫：\n Name With default settings unquoted names are converted to upper case. There is no maximum name length.\nIdentifiers in H2 are case sensitive by default. Because unquoted names are converted to upper case, they can be written in any case anyway. When both quoted and unquoted names are used for the same identifier the quoted names must be written in upper case. Identifiers with lowercase characters can be written only as a quoted name, they aren\u0026rsquo;t accessible with unquoted names.\nIf DATABASE_TO_UPPER setting is set to FALSE the unquoted names aren\u0026rsquo;t converted to upper case.\nIf DATABASE_TO_LOWER setting is set to TRUE the unquoted names are converted to lower case instead.\nIf CASE_INSENSITIVE_IDENTIFIERS setting is set to TRUE all identifiers are case insensitive.\n 所以如果要保持 SQL 中的大小寫必須用 \u0026quot;\u0026quot; 括起來：\n Quoted Name | \u0026quot; anything \u0026quot; |\nCase of characters in quoted names is preserved as is. Such names can contain spaces. There is no maximum name length. Two double quotes can be used to create a single double quote inside an identifier. With default settings identifiers in H2 are case sensitive.\nExample:\n\u0026ldquo;FirstName\u0026rdquo;\n 因此如果上面的 NativeQuery 改寫成：\nString sql = \u0026#34;select Name as \\\u0026#34;Name\\\u0026#34;, SeqNo as \\\u0026#34;SeqNo\\\u0026#34; from Test where Name = :name\u0026#34;; List\u0026lt;Tuple\u0026gt; result = entityManager.createNativeQuery(sql, Tuple.class).setParameter(\u0026#34;name\u0026#34;, name) .getResultList(); return result; 就可以正常回傳 Name 和 SeqNo：\n其實這件事也讓我在思考，使用像 H2 這樣的 Memory Database 雖然可以加速測試，但畢竟它和正式線上的資料庫不同，這樣的話這些測試是否能真實反映出實際的狀況呢?或者在 Unit Test 時直接使用如 DBUnit 這類的模擬假資料，反正使用 H2 模擬的也一樣只是假資料，而在 Integration Test 時使用和正式環境相同的資料庫這樣才更有意義也不一定?\n如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/sql-and-h2-db/"},{"title":"LeetCode 55. Jump Game","date":"","description":"","body":"LeetCode 55. Jump Game Medium\nGiven an array of non-negative integers nums, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\nExample 1:\nInput: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:\nInput: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 104 0 \u0026lt;= nums[i] \u0026lt;= 105  解決方法 1 (My Own Solution) 根據題目的說明，我們從第 1 個 index 出發，其數字為可走的步數，所以反過來如果我們從最後一個 index 開始往前，只要前 1 個 index 的元素也就是可走的步數大於或等於兩個 index 間的距離就表示可以有辦法走到下一個 index，我們就可以再往前走。 以 Example 1 為例：\n index 3 的步數為 1，等於 index 3 到 index 4 (同時也是終點)的距離 1 表示有辦法走到終點，所以我們可以再往前一個 index 檢查。 index 2 的步數為 1，等於 index 2 到 index 3 的距離 1，再往前一個 index。 index 1 的步數為 3 大於 index 1 到 index 2 的距離 1，再往前一個 index。 index 0 的步數為 2 大於 index 0 到 index 1 的距離 1，因為已經走到起點了，所以 Example 1 的陣列可以從起點走到終點。  同樣的邏輯套用到 Exmaple 2 上:\n index 3 的步數為 0 小於 index 3 到 index 4 的距離 1，但因為在 index 3 之前還是可能有能走到 index 4 的步數，所以我們繼續往前檢查。 index 2 的步數為 1 小於 index 2 到 index 4 的距離 2 再往前 index 1 的步數為 2 小於 index 1 到index 4 的距離 3 再往 index 0 的步數為 3 小於 index 0 到 index 4 的距離 4，因為已經檢查到起點了，所以 Example 2 的陣列沒辦法從起點走到終點。  Java Code class Solution { public boolean canJump(int[] nums) { // 處理陣列長度為 1 時的特殊情況  if (nums.length == 1) { return true; } int i = nums.length - 2; // 兩個 index 間的距離  int distance = 1; // 從倒數第 2 個 index 開始檢查  for (; i \u0026gt;= 0; i--) { if (nums[i] \u0026gt;= distance) { // 如果走到起點表示此陣列可以從起點走到終點  if (i == 0) { return true; } // 當要檢查下一個 index 時，檢查距離重設為 1  distance = 1; continue; } // 如果此 index 的步數不滿足條件，則檢查下一個 index 時，檢查距離要加 1  distance++; } return i == 0; } }  時間複雜度：因為是遍歷陣列，所以時間複雜度為 $O(N)$  解法 2 (LeetCode Forum Solution) 解法方式和解法 1 相同，但程式碼簡潔更多。基本上是將解法 1 中的 index 的元素是否大於或等於 distance 的計算直接用 index + 該 index 的元素 是否大於或等於後一個 index 取代，同時會用 1 個 pointer last 指向可以成功走到後一個 index 的 index 為何，如果最後 last 指到 index 0 表示可以從起點走到終點。\nJava Code class Solution { public boolean canJump(int[] nums) { int last = nums.length - 1; for (int i = nums.length - 2; i \u0026gt;= 0; i--) { // index + index 的元素如果 \u0026gt;= 後 1 個 index, 表示可以從這邊走到後一個 index 的地方, 所以我們可以繼續往前檢查  if (i + nums[i] \u0026gt;= last) { last = i; } } return last == 0; } }  時間複雜度：因為需要遍歷陣列，所以同樣為 $O(N)$  解法 3 (LeetCode Forum Solution) 這個解法的思考方式是，我們從起點開始記錄該 index 的步數最遠可以到的 index (用變數 max 記錄)，然後開始往後遍歷，如果中間有 index 的步數可以把 max 再往更後面推進就更新 max 的值，但如果我們在遍歷的過程中所檢查的 index 已經超出 max 指向的 index，表示我們最遠只能到 max 所指向的 index 而無法到達終點。如果可以順利遍歷完表示 max 最終的數值一定是等於或大於終點的 index。 以 Example 1 為例的話：\n 開始 max = 0，起點 index 0 為 2 所以 max = 2 表示此時我們最遠可以到 index 2。 index 1 為 3 大於 max 所以更新 max = 3 表示此時我們最遠可以到 index 3。 index 2 為 1 小於 max 所以我們可以不用使用它。 index 3 為 1 小於 max 所以我們可以不用使用它。 index 4 為 4 大於 max，同時我們也遍歷到終點了，所以我們可以成功地從起點走到終點。  以 Example 2 為例的話：\n 開始 max = 0，起點 index 0 為 3 所以 max = 3 表示此時我們最遠可以到 index 3。 index 1 為 2 小於 max 所以我們可以不用使用它。 index 2 為 1 小於 max 所以我們可以不用使用它。 index 3 為 0 小於 max 所以我們可以不用使用它。 index 4 為 4 但因為此時我們遍歷到的 index 已經超過 max 指向的 index 了，表示我們最遠只能走到 max 指向的 index 3，因此不可能從起點走到終點。  Java Code class Solution { public boolean canJump(int[] nums) { int max = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (i \u0026gt; max) { return false; } max = Math.max(i + nums[i], max); } return true; } }  時間複雜度：需要遍歷陣列，所以時間複雜度為 $O(N)$  如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-55/"},{"title":"LeetCode 344. Reverse String","date":"","description":"","body":"LeetCode 344. Reverse String Easy\n題目 Write a function that reverses a string. The input string is given as an array of characters char[].\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nYou may assume all the characters consist of printable ascii characters.\nExample 1:\nInput: [\u0026quot;h\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;o\u0026quot;] Output: [\u0026quot;o\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;h\u0026quot;] Example 2:\nInput: [\u0026quot;H\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;h\u0026quot;] Output: [\u0026quot;h\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;H\u0026quot;] 解決方法1 (My Own Solution) 用兩個指標 start 和 end 分別由陣列第一個和最後一個元素開始交換位置，並且彼此慢慢靠近，因為字串長度可能為奇數或偶數，所以直到 start \u0026gt;= end 為止 (當為奇數時 start == end，當為偶數時兩者會交錯所以用 start \u0026gt; end 判斷)。\nJava Code class Solution { public void reverseString(char[] s) { int end = s.length - 1; for (int start = 0; start \u0026lt; s.length; start++) { if (start \u0026gt;= end) { return; } char temp = s[start]; s[start] = s[end]; s[end] = temp; end--; } } } 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-344/"},{"title":"從 Server 端輸出下載的檔名含有中文會變成亂碼問題","date":"","description":"","body":"朋友遇到一個問題是如果檔名有中文，在瀏覽器下載時檔名會變成亂碼。\n首先，瀏覽器是用 header 中的 Content-Disposition=attachment;filename=${檔名} 做為預設的下載檔名，但 header 中並不支援 UTF-8 編碼，所以如果在程式中直接拿中文檔名放在 filename 中就會變成亂碼。\n解決方法是先把檔名 encode 成 URL-encoded 編碼，在 Java 中可以用 URLEncoder 處理：\nresponse.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;filename=\u0026#34; + URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;); 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/garbled-file-name/"},{"title":"About","date":"","description":"","body":"一名充滿好奇心的小小工程師，學習程式喜歡了解探究原理。因為自知美感欠知所以興趣集中在後端系統上，覺得看到大系統中每個組件能完美地契合運作是件非常美妙的事。 這裡記錄著各種學習記錄、工作上遇到的各種問題和解法，如果有錯誤的地方歡迎指教。\nEmail: blackdiz@gmail.com\nGithub: https://github.com/blackdiz\n","ref":"/about/"},{"title":"LeetCode 1. Two Sum","date":"","description":"","body":"LeetCode 1. Two Sum Easy\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\nGiven nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解決方法 1 (My Own Solution) 直覺的話就是暴力解法，用所有元素組合兩兩相加直到找出加總等於 target 為止。\nJava Code class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; for (int j = i + 1; j \u0026lt; nums.length; j++) { if (num1 + nums[j] == target) { return new int[]{i, j}; } } } return new int[0]; } } 時間複雜度：每個元素都要遍歷陣列一次，所以有 $N$ 個元素時為 $O(N^2)$。\n解決方法 2 (My Own Solution) 使用 Map 將 {數字 : index} 儲存起來，在遍歷陣列時直接從 Map 取差值，如果有取到則回傳兩者的 index。\nJava Code class Solution { public int twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; records = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { records.put(nums[i], i); } for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; int num2 = target - num1; // 第 2 個條件避免找到自己，例如 6 - 3 = 3 的情況  if (records.get(num2) != null \u0026amp;\u0026amp; records.get(num2) != i) { return new int[]{i, records.get(num2)}; } } return new int[0]; } } 時間複雜度：遍歷 2 次，所以 $N$ 個元素時為 $O(N)$ 空間複雜度：需要用 Map 記錄陣列中的數字和 index，所以為 $O(N)$\n解決方法 3 (LeetCode Solution) 解決方法 2 可以再進一步優化，因為我們是用差值去 Map 中確認有無和差值相同的元素存在，所以如果 num1 + num2 = target 在遇到 num1 時，我們即使用差值 num2 取不到也將 num1 和它的 index 存入 Map 中，在遇到 num2 時用差值 num1 就可以取到 num1 的 index，所以我們可以不用先將陣列中的元素存入 Map 中，而是一邊遍歷一邊存入 Map。 例如 [2, 7, 3, 4] 而 target = 9，遍歷時先遇到 2，差值為 7，此時 Map 中沒有 7 但我們先把 {2: 0} 存入 Map，而繼續遍歷下去遇到 7，差值為 2，此時我們可以在 Map 取到 {2:0}，所以答案就是 [1, 0]。\nJava Code class Solution { public int twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; records = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int num1 = nums[i]; int num2 = target - num1; if (records.get(num2) != null) { return new int[]{i, records.get(num2)}; } records.put(num1, i); } return new int[0]; } } Go Code func twoSum(nums []int, target int) []int { record := make(map[int]int) for i := 0; i \u0026lt; len(nums); i++ { n1, ok := record[target - nums[i]]; if (ok) { return []int{i, n1} } record[nums[i]] = i } return []int{} } 時間複雜度：需要遍歷 $N$ 個元素，所以為 $O(N)$ 空間複雜度：需要建立儲存 $N$ 個元素的 Map，所以為 $O(N)$\n如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄\n","ref":"/blog/leetcode-1/"}]