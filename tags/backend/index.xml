<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>backend on Blackdiz's Garage</title><link>https://blackdiz.github.io/tags/backend/</link><description>Recent content in backend on Blackdiz's Garage</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Tue, 06 Jul 2021 01:28:39 +0800</lastBuildDate><atom:link href="https://blackdiz.github.io/tags/backend/index.xml" rel="self" type="application/rss+xml"/><item><title>Use FreeMarker Template to Output JSON</title><link>https://blackdiz.github.io/blog/freemarker-json/</link><pubDate>Tue, 06 Jul 2021 01:28:39 +0800</pubDate><guid>https://blackdiz.github.io/blog/freemarker-json/</guid><description>Use FreeMarker Template to Output JSON 首先我們先準備一個 FreeMarker 的 template: test.fltj, fltj 是我們自創給 JSON 格式 tempalte 的副檔名:
{ &amp;#34;name&amp;#34;: &amp;#34;test&amp;#34;, ${content} } ${content} 就是我們等會兒要動態設置的部分。
接著我們需要建立 FreeMarker 的 Configruation，這個 Configuration 理論上只需要建立一個：
Configuration configuration = new Configuration(Configuration.VERSION_2_3_25); // 這裡設定 JSON 範本的路徑 configuration.setClassForTemplateLoading(this.getClass(), &amp;#34;/templates/json-templates&amp;#34;); configuration.setDefaultEncoding(&amp;#34;UTF-8&amp;#34;); configuration.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER); configuration.setLogTemplateExceptions(false); 然後我們使用 jackson 這個 library 來幫我們把 Java 物件轉成 JSON 格式的字串：
Map&amp;lt;String, Object&amp;gt; data = new HashMap&amp;lt;&amp;gt;(); data.put(&amp;#34;text&amp;#34;, &amp;#34;test message&amp;#34;); data.put(&amp;#34;age&amp;#34;, 23); data.put(&amp;#34;boolean&amp;#34;, true); ObjectMapper mapper = new ObjectMapper(); // writerWithDefaultPrettyPrinter() 會排版輸出的結果 String jsonString = mapper.</description></item><item><title>H2 Database and SQL Alias Column Name</title><link>https://blackdiz.github.io/blog/sql-and-h2-db/</link><pubDate>Tue, 08 Jun 2021 07:59:46 +0800</pubDate><guid>https://blackdiz.github.io/blog/sql-and-h2-db/</guid><description>朋友問了一個奇妙的狀況，下面這個 Spring JPA 的 NativeQuery 回傳的 column name 應該是 as 之後的名稱 (以下為測試的 NativeQuery，非朋友實際執行的 SQL)：
String sql = &amp;#34;select Name as Name, SeqNo as SeqNo from Test where Name = :name&amp;#34;; List&amp;lt;Tuple&amp;gt; result = entityManager.createNativeQuery(sql, Tuple.class).setParameter(&amp;#34;name&amp;#34;, name) .getResultList(); return result; 也就是 Name 和 SeqNo，但跑出來的結果卻是全大寫的 NAME 和 SEQNO：
而且我使用 SQLServer 測試時無法重現這個狀況。一開始以為是不是 Spring JPA 的設定問題，但 Google 大神沒有降什麼神旨，翻了 Spring JPA 的文件也沒看到什麼相關的設定，想說只好用 debug 模式來追蹤一下到底執行過程中是不是有什麼地方會去修改 alias column name。 在追蹤的過程中，突然看到這行：
雖然和執行過程無關 😅，但 factory.getJdbcServices().getDialect() 讓我想到朋友用的是 H2 Database，馬上去官網查了一下發現果然是因為 H2 預設對於沒有使用 &amp;quot;&amp;quot; 括起來的欄位名稱都會依設定轉成全大寫或全小寫：</description></item><item><title>從 Server 端輸出下載的檔名含有中文會變成亂碼問題</title><link>https://blackdiz.github.io/blog/garbled-file-name/</link><pubDate>Mon, 22 Mar 2021 15:15:46 +0800</pubDate><guid>https://blackdiz.github.io/blog/garbled-file-name/</guid><description>從 Server 端輸出下載的檔名含有中文會變成亂碼問題 朋友遇到一個問題是如果檔名有中文，在瀏覽器下載時檔名會變成亂碼。
首先，瀏覽器是用 header 中的 Content-Disposition=attachment;filename=${檔名} 做為預設的下載檔名，但 header 中並不支援 UTF-8 編碼，所以如果在程式中直接拿中文檔名放在 filename 中就會變成亂碼。
解決方法是先把檔名 encode 成 URL-encoded 編碼，在 Java 中可以用 URLEncoder 處理：
response.setHeader(&amp;#34;Content-Disposition&amp;#34;, &amp;#34;attachment;filename=&amp;#34; + URLEncoder.encode(fileName, &amp;#34;UTF-8&amp;#34;); 如果有什麼想法或需要指正的地方，歡迎您留言或來信 😄</description></item></channel></rss>